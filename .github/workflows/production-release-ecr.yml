name: Production Release ECR

on:
  push:
    branches: [ main ]
    tags: [ 'v*.*.*' ]  # Semantic versioning tags (e.g., v1.2.3)
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., 2.0.0)'
        required: true
        type: string
      environment:
        description: 'Target environment'
        required: true
        default: 'prod'
        type: choice
        options:
          - prod
          - staging
      force_deploy:
        description: 'Force deployment even without changes'
        required: false
        default: false
        type: boolean

env:
  # ECR Configuration
  AWS_REGION: ap-south-1
  API_IMAGE_NAME: finbert-rag/api
  UI_IMAGE_NAME: finbert-rag/ui

permissions:
  contents: write
  packages: write
  actions: read
  id-token: write

jobs:
  # ===== VERSION VALIDATION & TAGGING =====
  version-management:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      version-tag: ${{ steps.version.outputs.tag }}
      is-release: ${{ steps.version.outputs.is-release }}
      should-deploy: ${{ steps.version.outputs.should-deploy }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine version and deployment strategy
        id: version
        run: |
          # Determine version based on trigger type
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ inputs.version }}"
            IS_RELEASE="true"
            SHOULD_DEPLOY="true"
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${{ github.ref_name }}"
            VERSION=${VERSION#v}  # Remove 'v' prefix if present
            IS_RELEASE="true"
            SHOULD_DEPLOY="true"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            # Main branch push - extract version from recent commits
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            LATEST_TAG=${LATEST_TAG#v}
            
            # Check if we have deployment-related commits
            if git log --oneline -10 | grep -E "(deploy|release|production|ECR)" || [[ "${{ inputs.force_deploy }}" == "true" ]]; then
              VERSION="${LATEST_TAG}"
              IS_RELEASE="false"
              SHOULD_DEPLOY="true"
            else
              VERSION="${LATEST_TAG}"
              IS_RELEASE="false"
              SHOULD_DEPLOY="false"
            fi
          fi

          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "tag=v${VERSION}" >> $GITHUB_OUTPUT
          echo "is-release=${IS_RELEASE}" >> $GITHUB_OUTPUT
          echo "should-deploy=${SHOULD_DEPLOY}" >> $GITHUB_OUTPUT

          echo "üè∑Ô∏è Version: ${VERSION}"
          echo "üì¶ Tag: v${VERSION}"
          echo "üöÄ Is Release: ${IS_RELEASE}"
          echo "üéØ Should Deploy: ${SHOULD_DEPLOY}"

  # ===== ENSURE INFRASTRUCTURE =====
  ensure-infrastructure:
    needs: version-management
    if: needs.version-management.outputs.should-deploy == 'true'
    runs-on: ubuntu-latest
    outputs:
      cluster_name: ${{ steps.cdk.outputs.cluster_name }}
      api_service_name: ${{ steps.cdk.outputs.api_service_name }}
      api_load_balancer_dns: ${{ steps.cdk.outputs.api_load_balancer_dns }}
      api_task_definition: ${{ steps.ecs.outputs.api_task_definition }}
      ui_service_name: ${{ steps.cdk.outputs.ui_service_name }}
      ui_load_balancer_dns: ${{ steps.cdk.outputs.ui_load_balancer_dns }}
      ui_task_definition: ${{ steps.ecs.outputs.ui_task_definition }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Resolve AWS account
        id: account
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=${ACCOUNT_ID}" >> $GITHUB_OUTPUT

      - name: Install CDK dependencies
        working-directory: infrastructure
        run: npm ci --ignore-scripts

      - name: Ensure production infrastructure exists
        working-directory: infrastructure
        env:
          CDK_DEFAULT_ACCOUNT: ${{ steps.account.outputs.account_id }}
          CDK_DEFAULT_REGION: ${{ env.AWS_REGION }}
        run: |
          npx cdk deploy FinBertRagProdStack \
            --require-approval never \
            --progress events \
            --outputs-file cdk-outputs.json

      - name: Capture stack outputs
        id: cdk
        working-directory: infrastructure
        run: |
          STACK_OUTPUTS=$(cat cdk-outputs.json)
          CLUSTER_NAME=$(echo "${STACK_OUTPUTS}" | jq -r '.FinBertRagProdStack.ClusterName')
          API_SERVICE_NAME=$(echo "${STACK_OUTPUTS}" | jq -r '.FinBertRagProdStack.ServiceName // ""')
          API_ALB_DNS=$(echo "${STACK_OUTPUTS}" | jq -r '.FinBertRagProdStack.LoadBalancerDNS // ""')
          UI_SERVICE_NAME=$(echo "${STACK_OUTPUTS}" | jq -r '.FinBertRagProdStack.UiServiceName // ""')
          UI_ALB_DNS=$(echo "${STACK_OUTPUTS}" | jq -r '.FinBertRagProdStack.UiLoadBalancerDNS // ""')

          if [[ -z "${CLUSTER_NAME}" || "${CLUSTER_NAME}" == "null" ]]; then
            echo "‚ùå Failed to resolve ECS cluster name from CDK outputs"
            exit 1
          fi

          echo "cluster_name=${CLUSTER_NAME}" >> $GITHUB_OUTPUT
          echo "api_service_name=${API_SERVICE_NAME}" >> $GITHUB_OUTPUT
          echo "api_load_balancer_dns=${API_ALB_DNS}" >> $GITHUB_OUTPUT
          echo "ui_service_name=${UI_SERVICE_NAME}" >> $GITHUB_OUTPUT
          echo "ui_load_balancer_dns=${UI_ALB_DNS}" >> $GITHUB_OUTPUT

      - name: Discover current task definition
        id: ecs
        env:
          CLUSTER_NAME: ${{ steps.cdk.outputs.cluster_name }}
          API_SERVICE_NAME: ${{ steps.cdk.outputs.api_service_name }}
          UI_SERVICE_NAME: ${{ steps.cdk.outputs.ui_service_name }}
        run: |
          if [[ -z "${API_SERVICE_NAME}" || "${API_SERVICE_NAME}" == "null" ]]; then
            echo "‚ö†Ô∏è API service name not exported by CDK. Attempting lookup..."
            API_SERVICE_NAME=$(aws ecs list-services \
              --cluster "${CLUSTER_NAME}" \
              --region ${{ env.AWS_REGION }} \
              --query 'serviceArns[0]' --output text | awk -F'/' '{print $NF}')
            if [[ -z "${API_SERVICE_NAME}" || "${API_SERVICE_NAME}" == "None" ]]; then
              echo "‚ùå Unable to resolve ECS API service name"
              exit 1
            fi
          fi

          API_TASK_DEFINITION=$(aws ecs describe-services \
            --cluster "${CLUSTER_NAME}" \
            --services "${API_SERVICE_NAME}" \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].taskDefinition' \
            --output text)

          if [[ -z "${API_TASK_DEFINITION}" || "${API_TASK_DEFINITION}" == "None" ]]; then
            echo "‚ùå Failed to retrieve current task definition for ${API_SERVICE_NAME}"
            exit 1
          fi

          echo "api_task_definition=${API_TASK_DEFINITION}" >> $GITHUB_OUTPUT
          echo "api_service_name=${API_SERVICE_NAME}" >> $GITHUB_OUTPUT

          if [[ -n "${UI_SERVICE_NAME}" && "${UI_SERVICE_NAME}" != "null" ]]; then
            UI_TASK_DEFINITION=$(aws ecs describe-services \
              --cluster "${CLUSTER_NAME}" \
              --services "${UI_SERVICE_NAME}" \
              --region ${{ env.AWS_REGION }} \
              --query 'services[0].taskDefinition' \
              --output text)

            if [[ -z "${UI_TASK_DEFINITION}" || "${UI_TASK_DEFINITION}" == "None" ]]; then
              echo "‚ö†Ô∏è Unable to retrieve task definition for ${UI_SERVICE_NAME}. UI deployment will be skipped."
            else
              echo "ui_task_definition=${UI_TASK_DEFINITION}" >> $GITHUB_OUTPUT
              echo "ui_service_name=${UI_SERVICE_NAME}" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ÑπÔ∏è UI service outputs not present, skipping UI task definition discovery."
          fi

  # ===== BUILD AND PUSH TO ECR =====
  build-and-push:
    needs: version-management
    if: needs.version-management.outputs.should-deploy == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [api, ui]
    
    outputs:
      api-image-uri: ${{ steps.image-uri.outputs.api-image-uri }}
      ui-image-uri: ${{ steps.image-uri.outputs.ui-image-uri }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Resolve AWS account
        id: account
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=${ACCOUNT_ID}" >> $GITHUB_OUTPUT

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Create ECR repository if not exists
        run: |
          if [[ "${{ matrix.service }}" == "api" ]]; then
            REPO_NAME="${{ env.API_IMAGE_NAME }}"
          else
            REPO_NAME="${{ env.UI_IMAGE_NAME }}"
          fi
          
          # Check if repository exists, create if not
          if ! aws ecr describe-repositories --repository-names "${REPO_NAME}" --region ${{ env.AWS_REGION }} 2>/dev/null; then
            echo "Creating ECR repository: ${REPO_NAME}"
            aws ecr create-repository \
              --repository-name "${REPO_NAME}" \
              --region ${{ env.AWS_REGION }} \
              --image-scanning-configuration scanOnPush=true
          else
            echo "ECR repository ${REPO_NAME} already exists"
          fi

      - name: Build Docker image
        run: |
          ACCOUNT_ID="${{ steps.account.outputs.account_id }}"
          REGISTRY="${ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"

          if [[ "${{ matrix.service }}" == "api" ]]; then
            DOCKERFILE="docker/Dockerfile.api"
            IMAGE_NAME="${REGISTRY}/${{ env.API_IMAGE_NAME }}"
          else
            DOCKERFILE="docker/Dockerfile.ui"
            IMAGE_NAME="${REGISTRY}/${{ env.UI_IMAGE_NAME }}"
          fi

          VERSION="${{ needs.version-management.outputs.version }}"
          
          # Build with multiple tags
          docker build \
            -t ${IMAGE_NAME}:latest \
            -t ${IMAGE_NAME}:${VERSION} \
            -t ${IMAGE_NAME}:prod \
            -f ${DOCKERFILE} .

      - name: Push Docker images to ECR
        run: |
          ACCOUNT_ID="${{ steps.account.outputs.account_id }}"
          REGISTRY="${ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"

          if [[ "${{ matrix.service }}" == "api" ]]; then
            IMAGE_NAME="${REGISTRY}/${{ env.API_IMAGE_NAME }}"
          else
            IMAGE_NAME="${REGISTRY}/${{ env.UI_IMAGE_NAME }}"
          fi

          VERSION="${{ needs.version-management.outputs.version }}"
          
          # Push all tags
          docker push ${IMAGE_NAME}:latest
          docker push ${IMAGE_NAME}:${VERSION}
          docker push ${IMAGE_NAME}:prod

      - name: Output image URIs
        id: image-uri
        run: |
          ACCOUNT_ID="${{ steps.account.outputs.account_id }}"
          REGISTRY="${ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"

          if [[ "${{ matrix.service }}" == "api" ]]; then
            IMAGE_URI="${REGISTRY}/${{ env.API_IMAGE_NAME }}:${{ needs.version-management.outputs.version }}"
            echo "api-image-uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
          else
            IMAGE_URI="${REGISTRY}/${{ env.UI_IMAGE_NAME }}:${{ needs.version-management.outputs.version }}"
            echo "ui-image-uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
          fi

  # ===== SECURITY SCANNING =====
  security-scan:
    needs: [version-management, build-and-push]
    if: needs.version-management.outputs.should-deploy == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Scan ECR images for vulnerabilities
        run: |
          VERSION="${{ needs.version-management.outputs.version }}"
          
          # Scan API image
          echo "üîç Scanning API image for vulnerabilities..."
          aws ecr start-image-scan \
            --repository-name "${{ env.API_IMAGE_NAME }}" \
            --image-id imageTag=${VERSION} \
            --region ${{ env.AWS_REGION }} || true

          # Scan UI image
          echo "üîç Scanning UI image for vulnerabilities..."
          aws ecr start-image-scan \
            --repository-name "${{ env.UI_IMAGE_NAME }}" \
            --image-id imageTag=${VERSION} \
            --region ${{ env.AWS_REGION }} || true

          # Wait for scans to complete and get results
          sleep 30
          
          echo "üìä API image scan results:"
          aws ecr describe-image-scan-findings \
            --repository-name "${{ env.API_IMAGE_NAME }}" \
            --image-id imageTag=${VERSION} \
            --region ${{ env.AWS_REGION }} \
            --query 'imageScanFindings.findingCounts' || echo "No scan results yet"

          echo "üìä UI image scan results:"
          aws ecr describe-image-scan-findings \
            --repository-name "${{ env.UI_IMAGE_NAME }}" \
            --image-id imageTag=${VERSION} \
            --region ${{ env.AWS_REGION }} \
            --query 'imageScanFindings.findingCounts' || echo "No scan results yet"

  # ===== ECS DEPLOYMENT =====
  deploy-to-ecs:
    needs: [version-management, build-and-push, security-scan, ensure-infrastructure]
    if: needs.version-management.outputs.should-deploy == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Resolve AWS account
        id: account
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=${ACCOUNT_ID}" >> $GITHUB_OUTPUT

      - name: Deploy to ECS
        run: |
          set -euo pipefail

          VERSION="${{ needs.version-management.outputs.version }}"
          CLUSTER_NAME="${{ needs.ensure-infrastructure.outputs.cluster_name }}"
          API_SERVICE_NAME="${{ needs.ensure-infrastructure.outputs.api_service_name }}"
          API_TASK_DEFINITION="${{ needs.ensure-infrastructure.outputs.api_task_definition }}"
          UI_SERVICE_NAME="${{ needs.ensure-infrastructure.outputs.ui_service_name }}"
          UI_TASK_DEFINITION="${{ needs.ensure-infrastructure.outputs.ui_task_definition }}"
          ACCOUNT_ID="${{ steps.account.outputs.account_id }}"
          ECR_REGISTRY="${ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          API_IMAGE_URI="${ECR_REGISTRY}/${{ env.API_IMAGE_NAME }}:${VERSION}"
          UI_IMAGE_URI="${ECR_REGISTRY}/${{ env.UI_IMAGE_NAME }}:${VERSION}"

          SERVICES_TO_WAIT=()

          update_service_image() {
            local label="$1"
            local service_name="$2"
            local current_task_definition="$3"
            local container_name="$4"
            local new_image="$5"

            if [[ -z "${service_name}" || "${service_name}" == "null" ]]; then
              echo "‚ÑπÔ∏è ${label} service name not provided. Skipping."
              return
            fi

            local effective_task_definition="${current_task_definition}"
            if [[ -z "${effective_task_definition}" || "${effective_task_definition}" == "None" || "${effective_task_definition}" == "null" ]]; then
              echo "‚ö†Ô∏è Task definition for ${label} not supplied. Attempting lookup."
              effective_task_definition=$(aws ecs describe-services \
                --cluster "${CLUSTER_NAME}" \
                --services "${service_name}" \
                --region ${{ env.AWS_REGION }} \
                --query 'services[0].taskDefinition' \
                --output text)
            fi

            if [[ -z "${effective_task_definition}" || "${effective_task_definition}" == "None" ]]; then
              echo "‚ùå Unable to resolve task definition for ${label} (${service_name})."
              return
            fi

            echo "üöÄ Deploying ${label} image ${new_image} to ${service_name} on ${CLUSTER_NAME}"

            local task_definition_json
            task_definition_json=$(aws ecs describe-task-definition \
              --task-definition "${effective_task_definition}" \
              --region ${{ env.AWS_REGION }} \
              --query 'taskDefinition' \
              --output json)

            local updated_td_file
            updated_td_file=$(mktemp)
            echo "${task_definition_json}" | jq \
              --arg IMAGE "${new_image}" \
              --arg CONTAINER "${container_name}" \
              '.containerDefinitions = (.containerDefinitions | map(
                if .name == $CONTAINER then .image = $IMAGE else . end
              )) | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)' \
              > "${updated_td_file}"

            if [[ ! -s "${updated_td_file}" ]]; then
              echo "‚ùå Updated task definition payload for ${label} is empty"
              rm -f "${updated_td_file}"
              exit 1
            fi

            local new_task_definition
            new_task_definition=$(aws ecs register-task-definition \
              --cli-input-json file://"${updated_td_file}" \
              --region ${{ env.AWS_REGION }} \
              --query 'taskDefinition.taskDefinitionArn' \
              --output text)

            rm -f "${updated_td_file}"

            echo "üìã ${label} task definition registered: ${new_task_definition}"

            aws ecs update-service \
              --cluster "${CLUSTER_NAME}" \
              --service "${service_name}" \
              --task-definition "${new_task_definition}" \
              --region ${{ env.AWS_REGION }}

            SERVICES_TO_WAIT+=("${service_name}")
          }

          update_service_image "API" "${API_SERVICE_NAME}" "${API_TASK_DEFINITION}" "finbert-api" "${API_IMAGE_URI}"

          if [[ -n "${UI_SERVICE_NAME}" && "${UI_SERVICE_NAME}" != "null" ]]; then
            update_service_image "UI" "${UI_SERVICE_NAME}" "${UI_TASK_DEFINITION}" "finbert-ui" "${UI_IMAGE_URI}"
          else
            echo "‚ÑπÔ∏è UI service not configured for deployment workflow run."
          fi

          if (( ${#SERVICES_TO_WAIT[@]} > 0 )); then
            echo "‚è≥ Waiting for services to stabilize: ${SERVICES_TO_WAIT[*]}"
            aws ecs wait services-stable \
              --cluster "${CLUSTER_NAME}" \
              --services "${SERVICES_TO_WAIT[@]}" \
              --region ${{ env.AWS_REGION }}
            echo "‚úÖ ECS deployment completed successfully"
          else
            echo "‚ÑπÔ∏è No ECS services updated during this run."
          fi

  # ===== HEALTH CHECK & VALIDATION =====
  validate-deployment:
    needs: [version-management, ensure-infrastructure, deploy-to-ecs]
    if: needs.version-management.outputs.should-deploy == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get Load Balancer DNS
        id: lb-dns
        run: |
          API_DNS="${{ needs.ensure-infrastructure.outputs.api_load_balancer_dns }}"
          UI_DNS="${{ needs.ensure-infrastructure.outputs.ui_load_balancer_dns }}"

          if [[ -z "${API_DNS}" || "${API_DNS}" == "null" ]]; then
            API_DNS=$(aws elbv2 describe-load-balancers \
              --query 'LoadBalancers[0].DNSName' \
              --output text \
              --region ${{ env.AWS_REGION }})
          fi

          if [[ "${UI_DNS}" == "null" ]]; then
            UI_DNS=""
          fi
          
          echo "api_dns=${API_DNS}" >> $GITHUB_OUTPUT
          echo "ui_dns=${UI_DNS}" >> $GITHUB_OUTPUT
          echo "üåê API Load Balancer DNS: ${API_DNS}"
          if [[ -n "${UI_DNS}" ]]; then
            echo "üé® UI Load Balancer DNS: ${UI_DNS}"
          else
            echo "üé® UI Load Balancer DNS: (not configured)"
          fi

      - name: Health Check
        run: |
          API_DNS="${{ steps.lb-dns.outputs.api_dns }}"
          MAX_ATTEMPTS=30
          ATTEMPT=1

          echo "üîç Starting health check validation..."
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: Checking health endpoint..."
            
            if curl -f -s "http://${API_DNS}/health" > /dev/null; then
              echo "‚úÖ Health check passed!"
              curl -s "http://${API_DNS}/health" | jq '.'
              break
            else
              echo "‚è≥ Health check failed, waiting 10 seconds..."
              sleep 10
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
          done

          if [ $ATTEMPT -gt $MAX_ATTEMPTS ]; then
            echo "‚ùå Health check failed after $MAX_ATTEMPTS attempts"
            exit 1
          fi

      - name: API Endpoint Testing
        run: |
          API_DNS="${{ steps.lb-dns.outputs.api_dns }}"
          
          echo "üß™ Testing API endpoints..."

          # Test 384d embedding endpoint
          echo "Testing 384d endpoint..."
          curl -X POST "http://${API_DNS}/search/cosine/embedding384d/" \
            -H "Content-Type: application/json" \
            -d '{"query": "artificial intelligence investment", "size": 1}' \
            -f -s | jq '.results | length'

          # Test 768d embedding endpoint
          echo "Testing 768d endpoint..."
          curl -X POST "http://${API_DNS}/search/cosine/embedding768d/" \
            -H "Content-Type: application/json" \
            -d '{"query": "financial market analysis", "size": 1}' \
            -f -s | jq '.results | length'

          # Test 1155d enhanced endpoint
          echo "Testing 1155d endpoint..."
          curl -X POST "http://${API_DNS}/search/cosine/embedding1155d/" \
            -H "Content-Type: application/json" \
            -d '{"query": "sovereign debt instruments", "size": 1}' \
            -f -s | jq '.results | length'

          echo "‚úÖ All API endpoints responding successfully"

      - name: UI Health Check
        if: ${{ steps.lb-dns.outputs.ui_dns != '' && steps.lb-dns.outputs.ui_dns != 'null' }}
        run: |
          UI_DNS="${{ steps.lb-dns.outputs.ui_dns }}"
          MAX_ATTEMPTS=20
          ATTEMPT=1

          echo "üîç Starting Streamlit UI health validation..."
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: Checking /_stcore/health..."
            
            if curl -f -s "http://${UI_DNS}/_stcore/health" > /dev/null; then
              echo "‚úÖ UI health check passed!"
              break
            else
              echo "‚è≥ UI health check failed, waiting 10 seconds..."
              sleep 10
            fi
            
            ATTEMPT=$((ATTEMPT + 1))
          done

          if [ $ATTEMPT -gt $MAX_ATTEMPTS ]; then
            echo "‚ùå UI health check failed after $MAX_ATTEMPTS attempts"
            exit 1
          fi

      - name: UI Endpoint Smoke Test
        if: ${{ steps.lb-dns.outputs.ui_dns != '' && steps.lb-dns.outputs.ui_dns != 'null' }}
        run: |
          UI_DNS="${{ steps.lb-dns.outputs.ui_dns }}"
          echo "üß™ Fetching Streamlit UI root..."
          curl -f -s "http://${UI_DNS}/" > /dev/null
          echo "‚úÖ Streamlit UI responding successfully"

      - name: Performance Validation
        run: |
          API_DNS="${{ steps.lb-dns.outputs.api_dns }}"
          
          echo "‚ö° Performance validation..."
          
          # Test response time for each endpoint
          for endpoint in "embedding384d" "embedding768d" "embedding1155d"; do
            echo "Testing ${endpoint} performance..."
            
            response_time=$(curl -X POST "http://${API_DNS}/search/cosine/${endpoint}/" \
              -H "Content-Type: application/json" \
              -d '{"query": "performance test", "size": 1}' \
              -w "%{time_total}" -s -o /dev/null)
            
            echo "${endpoint}: ${response_time}s"
            
            # Check if response time is under 1 second
            if (( $(echo "${response_time} < 1.0" | bc -l) )); then
              echo "‚úÖ ${endpoint} performance: ${response_time}s (< 1.0s)"
            else
              echo "‚ö†Ô∏è  ${endpoint} performance: ${response_time}s (>= 1.0s)"
            fi
          done

  # ===== NOTIFICATION =====
  notify-deployment:
    needs: [version-management, validate-deployment]
    if: always() && needs.version-management.outputs.should-deploy == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Deployment Status Summary
        run: |
          VERSION="${{ needs.version-management.outputs.version }}"
          
          echo "üöÄ Production Deployment Summary"
          echo "================================"
          echo "Version: ${VERSION}"
          echo "Environment: ${{ inputs.environment || 'prod' }}"
          echo "Registry: ${{ env.ECR_REGISTRY }}"
          echo "Deployment Status: ${{ job.status }}"
          
          if [[ "${{ needs.validate-deployment.result }}" == "success" ]]; then
            echo "‚úÖ Deployment successful and validated"
          else
            echo "‚ùå Deployment failed or validation issues"
          fi
