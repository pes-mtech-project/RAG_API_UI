# üîß INFRASTRUCTURE MANAGEMENT WORKFLOW
name: Infrastructure Management

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'create'
        type: choice
        options:
        - create
        - destroy

env:
  AWS_REGION: ap-south-1
  
jobs:
  infrastructure:
    runs-on: ubuntu-latest
    name: üèóÔ∏è Manage AWS Infrastructure
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      
    - name: üîê Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: üîß Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.6.0
        
    - name: üèóÔ∏è Create infrastructure
      if: ${{ inputs.action == 'create' }}
      run: |
        # Create infrastructure setup script
        cat > setup_infrastructure.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "üèóÔ∏è Setting up AWS infrastructure for FinBERT RAG App in ap-south-1..."
        
        # Set target region
        export AWS_DEFAULT_REGION=ap-south-1
        echo "üåè Working in ap-south-1 region"
        
        # Cleanup any existing terminated instances
        echo "üßπ Cleaning up terminated instances..."
        TERMINATED_INSTANCES=$(aws ec2 describe-instances --filters "Name=instance-state-name,Values=terminated" --query 'Reservations[*].Instances[*].InstanceId' --output text 2>/dev/null || echo "")
        if [ -n "$TERMINATED_INSTANCES" ]; then
          echo "Found terminated instances, they will be cleaned up automatically by AWS"
        fi
        if [ -n "$EXISTING_INSTANCE" ] && [ "$EXISTING_INSTANCE" != "None" ]; then
          echo "üõë Terminating existing instance: $EXISTING_INSTANCE"
          aws ec2 terminate-instances --instance-ids $EXISTING_INSTANCE
          echo "‚è≥ Waiting for instance termination..."
          aws ec2 wait instance-terminated --instance-ids $EXISTING_INSTANCE
          echo "‚úÖ Instance terminated"
        fi
        
        # Switch to ap-south-1
        export AWS_DEFAULT_REGION=ap-south-1
        echo "üåè Switched to ap-south-1 region"
        
        # Check available free tier instance types
        echo "üîç Checking free tier eligible instance types in ap-south-1..."
        aws ec2 describe-instance-types --filters Name=free-tier-eligible,Values=true --query 'InstanceTypes[].InstanceType' --output text || echo "Could not check free tier types"
        
        # Setup SSH key pair - ALWAYS use the same key for consistency
        KEY_NAME="finbert-rag-key-new"
        echo "üîë Setting up SSH key pair: $KEY_NAME"
        
        # Always delete and recreate to ensure consistency
        echo "üßπ Cleaning up any existing key pair..."
        aws ec2 delete-key-pair --key-name $KEY_NAME 2>/dev/null || echo "No existing key to delete"
        
        # Import the specific public key that matches your private key
        echo "üì§ Importing your SSH public key..."
        
        # Create the public key content (this matches your finbert-rag-key-new.pem)
        PUBLIC_KEY="ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDgmTmruJ6hX7e7YM1VJ0j2MrZGyANVCOln77jumi1JmHDta65DeJf2e/saAu5W/dvkN9zw0iQtXTgaANdMq7Xn6mvz80CdIm2ckg0aDAJjKXv+R23QhrhVD/y/L7aEvSXQzP+O1+dK1TURSfCkXV5nXXp+mtJLBaFh46da9MS1lj6wF0TVFv6vdcpIDGAW+XcwUFCS1ppvzTiVk7hJ2yGn9L8lv7VStqxKTJpw0J97a+B70M7Ye2n5+5CA+WLiTifVcS9odFZotZ7b/0LcQISaFTnY+4oT4cvL9p2ataebRzDjWj+VEiwq5eRDEGzNXzsRdzDR6b3xwYem7ZAbsRpX"
        
        # Import the key pair using base64 encoding (remove line breaks for compatibility)
        if aws ec2 import-key-pair \
          --key-name $KEY_NAME \
          --public-key-material "$(echo "$PUBLIC_KEY" | base64 | tr -d '\n')" >/dev/null 2>&1; then
          echo "‚úÖ SSH key pair imported: $KEY_NAME"
        else
          echo "‚ÑπÔ∏è Key pair already exists or import failed, continuing..."
          # Verify the key exists
          if aws ec2 describe-key-pairs --key-names $KEY_NAME >/dev/null 2>&1; then
            echo "‚úÖ Verified existing key pair: $KEY_NAME"
          else
            echo "‚ùå Key pair issue - check AWS console"
            exit 1
          fi
        fi
        
        echo "üîë This key will work with your existing finbert-rag-key-new.pem file"
        
        # Setup IAM role for EC2 with SSM permissions (optional)
        echo "üîê Setting up IAM role for SSM access..."
        
        ROLE_NAME="FinBERT-RAG-EC2-SSM-Role"
        PROFILE_NAME="FinBERT-RAG-EC2-Profile"
        
        # Check if IAM operations are allowed
        if aws iam get-user >/dev/null 2>&1; then
          echo "‚úÖ IAM access available, creating role..."
          
          # Create trust policy for EC2
          cat > trust-policy.json << 'TRUST_EOF'
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "ec2.amazonaws.com"
              },
              "Action": "sts:AssumeRole"
            }
          ]
        }
        TRUST_EOF
          
          # Try to create IAM role
          if aws iam create-role --role-name $ROLE_NAME --assume-role-policy-document file://trust-policy.json >/dev/null 2>&1; then
            echo "‚úÖ IAM role created"
          else
            echo "‚ÑπÔ∏è IAM role already exists or creation failed"
          fi
          
          # Try to attach SSM policy
          aws iam attach-role-policy --role-name $ROLE_NAME --policy-arn arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore >/dev/null 2>&1 || echo "‚ÑπÔ∏è SSM policy attachment skipped"
          
          # Try to create instance profile
          aws iam create-instance-profile --instance-profile-name $PROFILE_NAME >/dev/null 2>&1 || echo "‚ÑπÔ∏è Instance profile exists"
          aws iam add-role-to-instance-profile --instance-profile-name $PROFILE_NAME --role-name $ROLE_NAME >/dev/null 2>&1 || echo "‚ÑπÔ∏è Role already in profile"
          
          echo "‚úÖ IAM setup completed"
        else
          echo "‚ö†Ô∏è No IAM access - proceeding without SSM role (will use SSH only)"
          PROFILE_NAME=""
        fi
        
        # Create security group
        SG_NAME="finbert-rag-sg"
        VPC_ID=$(aws ec2 describe-vpcs --filters "Name=isDefault,Values=true" --query 'Vpcs[0].VpcId' --output text)
        
        # Check if security group exists
        SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=$SG_NAME" --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "")
        
        if [ -z "$SG_ID" ] || [ "$SG_ID" = "None" ]; then
          echo "üõ°Ô∏è Creating Security Group..."
          SG_ID=$(aws ec2 create-security-group \
            --group-name $SG_NAME \
            --description "Security group for FinBERT RAG App" \
            --vpc-id $VPC_ID \
            --query 'GroupId' --output text)
          
          echo "‚úÖ Security group created: $SG_ID"
          
          # Add security group rules
          echo "üîß Adding security group rules..."
          aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port 22 --cidr 0.0.0.0/0
          aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port 80 --cidr 0.0.0.0/0  
          aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port 443 --cidr 0.0.0.0/0
          aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port 8000 --cidr 0.0.0.0/0
          aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port 8501 --cidr 0.0.0.0/0
          echo "‚úÖ Security group rules added"
        else
          echo "‚úÖ Security group already exists: $SG_ID"
        fi
        
        # Launch EC2 instance
        INSTANCE_NAME="finbert-rag-instance"
        
        # Check for existing running instance
        EXISTING_INSTANCE=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=$INSTANCE_NAME" "Name=instance-state-name,Values=running" --query 'Reservations[0].Instances[0].InstanceId' --output text 2>/dev/null || echo "None")
        
        if [ "$EXISTING_INSTANCE" = "None" ] || [ -z "$EXISTING_INSTANCE" ]; then
          echo "üöÄ No running instance found, launching new EC2 instance..."
          
          # Clean up any terminated instances (informational)
          TERMINATED_COUNT=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=$INSTANCE_NAME" "Name=instance-state-name,Values=terminated" --query 'length(Reservations[].Instances[])')
          if [ "$TERMINATED_COUNT" -gt 0 ]; then
            echo "‚ÑπÔ∏è Found $TERMINATED_COUNT terminated instances (will be auto-cleaned by AWS)"
          fi
          
          # User data script for instance initialization (minimal for reliability)
          cat > user_data.sh << 'USERDATA'
        #!/bin/bash
        # Minimal user data to avoid boot failures
        yum update -y
        yum install -y python3.11 python3.11-pip git
        
        # Create log file for debugging
        echo "$(date): User data script started" >> /var/log/user-data.log
        
        # Basic Python setup
        python3.11 -m pip install --upgrade pip
        
        # Create app directory
        mkdir -p /home/ec2-user/finbert-news-rag-app
        chown -R ec2-user:ec2-user /home/ec2-user/
        
        echo "$(date): User data script completed" >> /var/log/user-data.log
        USERDATA
          
          # Get the latest Amazon Linux 2023 AMI for ap-south-1
          echo "üîç Finding latest Amazon Linux 2023 AMI for ap-south-1..."
          AMI_ID=$(aws ec2 describe-images \
            --owners amazon \
            --filters 'Name=name,Values=al2023-ami-*-x86_64' 'Name=state,Values=available' 'Name=architecture,Values=x86_64' \
            --query 'Images | sort_by(@, &CreationDate) | [-1].ImageId' \
            --output text)
          
          # Validate AMI ID
          if [ -z "$AMI_ID" ] || [ "$AMI_ID" = "None" ] || [ "$AMI_ID" = "null" ]; then
            echo "‚ùå Failed to find Amazon Linux 2023 AMI"
            echo "Available AMIs:"
            aws ec2 describe-images --owners amazon --filters 'Name=name,Values=al2023-ami-*' --query 'Images[0:5].[ImageId,Name,CreationDate]' --output table
            exit 1
          fi
          
          echo "‚úÖ Using AMI: $AMI_ID in region: ap-south-1"
          
          # Get AMI details for validation
          AMI_NAME=$(aws ec2 describe-images --image-ids $AMI_ID --query 'Images[0].Name' --output text)
          echo "üìã AMI Name: $AMI_NAME"
          
          # Try t2.micro first
          INSTANCE_TYPE="t2.micro"
          echo "üöÄ Attempting to launch $INSTANCE_TYPE instance..."
          
          set +e  # Allow command to fail
          
          # Build instance launch command
          LAUNCH_CMD="aws ec2 run-instances --image-id $AMI_ID --count 1 --instance-type $INSTANCE_TYPE --key-name $KEY_NAME --security-group-ids $SG_ID"
          if [ -n "$PROFILE_NAME" ]; then
            LAUNCH_CMD="$LAUNCH_CMD --iam-instance-profile Name=$PROFILE_NAME"
          fi
          LAUNCH_CMD="$LAUNCH_CMD --user-data file://user_data.sh --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value='$INSTANCE_NAME'}]' --query 'Instances[0].InstanceId' --output text"
          
          echo "üöÄ Launching instance with command: $LAUNCH_CMD"
          INSTANCE_ID=$(eval $LAUNCH_CMD 2>/dev/null)
          
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "‚ö†Ô∏è t2.micro failed, trying t3.micro..."
            INSTANCE_TYPE="t3.micro"
            LAUNCH_CMD="aws ec2 run-instances --image-id $AMI_ID --count 1 --instance-type $INSTANCE_TYPE --key-name $KEY_NAME --security-group-ids $SG_ID"
            if [ -n "$PROFILE_NAME" ]; then
              LAUNCH_CMD="$LAUNCH_CMD --iam-instance-profile Name=$PROFILE_NAME"
            fi
            LAUNCH_CMD="$LAUNCH_CMD --user-data file://user_data.sh --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value='$INSTANCE_NAME'}]' --query 'Instances[0].InstanceId' --output text"
            
            INSTANCE_ID=$(eval $LAUNCH_CMD)
          fi
          set -e  # Re-enable exit on error
          
          # Validate instance creation
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ] || [ "$INSTANCE_ID" = "null" ]; then
            echo "‚ùå Failed to launch EC2 instance"
            echo "This could be due to:"
            echo "1. No available capacity in the region"  
            echo "2. Insufficient permissions"
            echo "3. Security group or VPC issues"
            exit 1
          fi
          
          echo "‚úÖ Instance launched successfully!"
          echo "Instance Type: $INSTANCE_TYPE"
          echo "Instance ID: $INSTANCE_ID"
          
          # Wait for instance to be running (with timeout)
          echo "‚è≥ Waiting for instance to be running..."
          if ! timeout 300 aws ec2 wait instance-running --instance-ids $INSTANCE_ID; then
            echo "‚ùå Instance failed to start within 5 minutes"
            echo "Instance may have failed to boot. Check the AWS console for details."
            exit 1
          fi
          
          echo "‚úÖ Instance is now running!"
          
          # Get or create Elastic IP
          echo "üåê Setting up Elastic IP..."
          
          # Check for existing unassigned Elastic IP
          EXISTING_EIP=$(aws ec2 describe-addresses --filters "Name=domain,Values=vpc" --query 'Addresses[?InstanceId==null][0].AllocationId' --output text 2>/dev/null || echo "")
          
          if [ -n "$EXISTING_EIP" ] && [ "$EXISTING_EIP" != "None" ]; then
            echo "‚úÖ Found existing unassigned Elastic IP: $EXISTING_EIP"
            ALLOCATION_ID=$EXISTING_EIP
            ELASTIC_IP=$(aws ec2 describe-addresses --allocation-ids $ALLOCATION_ID --query 'Addresses[0].PublicIp' --output text)
          else
            echo "üÜï Creating new Elastic IP..."
            ALLOCATION_ID=$(aws ec2 allocate-address --domain vpc --query 'AllocationId' --output text)
            ELASTIC_IP=$(aws ec2 describe-addresses --allocation-ids $ALLOCATION_ID --query 'Addresses[0].PublicIp' --output text)
            echo "‚úÖ Created new Elastic IP: $ELASTIC_IP ($ALLOCATION_ID)"
          fi
          
          # Associate Elastic IP with instance
          echo "üîó Associating Elastic IP with instance..."
          ASSOCIATION_ID=$(aws ec2 associate-address --instance-id $INSTANCE_ID --allocation-id $ALLOCATION_ID --query 'AssociationId' --output text)
          echo "‚úÖ Elastic IP associated: $ASSOCIATION_ID"
          
          # Get final public IP (should be the Elastic IP)
          PUBLIC_IP=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
          echo "üåê Instance Public IP (Elastic): $PUBLIC_IP"
          
          # Final validation
          echo "ÔøΩ Performing final validation..."
          INSTANCE_STATE=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query 'Reservations[0].Instances[0].State.Name' --output text)
          if [ "$INSTANCE_STATE" != "running" ]; then
            echo "‚ùå Instance is not in running state: $INSTANCE_STATE"
            exit 1
          fi
          
          # Test basic connectivity (port 22)
          echo "üîç Testing basic connectivity to port 22..."
          if timeout 10 bash -c "</dev/tcp/$PUBLIC_IP/22" 2>/dev/null; then
            echo "‚úÖ Port 22 is accessible"
          else
            echo "‚ö†Ô∏è Port 22 not accessible yet (instance may still be booting)"
          fi
          
          echo "ÔøΩüìã IMPORTANT: Add these to your GitHub Secrets:"
          echo "EC2_INSTANCE_ID=$INSTANCE_ID"
          echo "EC2_HOST=$PUBLIC_IP"
          echo "ELASTIC_IP_ALLOCATION_ID=$ALLOCATION_ID"
          echo ""
          echo "üéØ Instance Details:"
          echo "Region: ap-south-1 (Mumbai)"
          echo "Instance ID: $INSTANCE_ID"
          echo "Instance Type: $INSTANCE_TYPE"
          echo "Elastic IP: $PUBLIC_IP"
          echo "Allocation ID: $ALLOCATION_ID"
          echo "SSH Key: $KEY_NAME"
          
        else
          INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=$INSTANCE_NAME" "Name=instance-state-name,Values=running" --query 'Reservations[0].Instances[0].InstanceId' --output text)
          PUBLIC_IP=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
          echo "‚úÖ Instance already running: $INSTANCE_ID"
          echo "üåê Instance Public IP: $PUBLIC_IP"
        fi
        
        # Create Application Load Balancer (optional, for production)
        # This would go here if needed for higher availability
        
        echo "üéâ Infrastructure setup completed!"
        echo ""
        echo "üìã Next steps:"
        echo "1. Add EC2_INSTANCE_ID=$INSTANCE_ID to GitHub Secrets"
        echo "2. Add EC2_HOST=$PUBLIC_IP to GitHub Secrets"  
        echo "3. Add your private key to EC2_SSH_PRIVATE_KEY secret"
        echo "4. Run the deployment workflow"
        echo ""
        echo "üîó Access URLs (after deployment):"
        echo "API: http://$PUBLIC_IP/api/docs"
        echo "Streamlit: http://$PUBLIC_IP/"
        echo "Direct API: http://$PUBLIC_IP:8000/docs"
        echo "Direct Streamlit: http://$PUBLIC_IP:8501"
        EOF
        
        chmod +x setup_infrastructure.sh
        ./setup_infrastructure.sh
        
    - name: üßπ Destroy infrastructure
      if: ${{ inputs.action == 'destroy' }}
      run: |
        echo "üßπ Destroying AWS infrastructure..."
        export AWS_DEFAULT_REGION=ap-south-1
        
        # Step 1: Find and terminate all instances
        echo "üîç Finding instances to terminate..."
        INSTANCE_IDS=$(aws ec2 describe-instances \
          --filters "Name=instance-state-name,Values=running,pending,stopping,stopped" \
          --query 'Reservations[].Instances[].[InstanceId,Tags[?Key==`Name`].Value|[0]]' \
          --output text | grep -E "(finbert-rag|infrastructure-test)" | awk '{print $1}' || echo "")
        
        if [ -n "$INSTANCE_IDS" ]; then
          echo "üõë Terminating instances: $INSTANCE_IDS"
          for INSTANCE_ID in $INSTANCE_IDS; do
            echo "Terminating: $INSTANCE_ID"
            aws ec2 terminate-instances --instance-ids $INSTANCE_ID >/dev/null 2>&1 || echo "Failed to terminate $INSTANCE_ID"
          done
          
          echo "‚è≥ Waiting for all instances to terminate..."
          for INSTANCE_ID in $INSTANCE_IDS; do
            echo "Waiting for $INSTANCE_ID..."
            timeout 300 aws ec2 wait instance-terminated --instance-ids $INSTANCE_ID || echo "Timeout waiting for $INSTANCE_ID"
          done
          echo "‚úÖ All instances terminated"
        else
          echo "‚ÑπÔ∏è No instances found to terminate"
        fi
        
        # Step 2: Wait extra time for network interfaces to detach
        echo "‚è≥ Waiting 30 seconds for network interfaces to fully detach..."
        sleep 30
        
        # Step 3: Check for and clean up network interfaces
        SG_NAME="finbert-rag-sg"
        SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=$SG_NAME" --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "")
        
        if [ -n "$SG_ID" ] && [ "$SG_ID" != "None" ]; then
          echo "ÔøΩ Checking for dependent network interfaces..."
          DEPENDENT_ENIS=$(aws ec2 describe-network-interfaces --filters "Name=group-id,Values=$SG_ID" --query 'NetworkInterfaces[].NetworkInterfaceId' --output text 2>/dev/null || echo "")
          
          if [ -n "$DEPENDENT_ENIS" ]; then
            echo "üîß Found dependent network interfaces: $DEPENDENT_ENIS"
            for ENI in $DEPENDENT_ENIS; do
              echo "Checking ENI: $ENI"
              ENI_STATUS=$(aws ec2 describe-network-interfaces --network-interface-ids $ENI --query 'NetworkInterfaces[0].Status' --output text 2>/dev/null || echo "")
              if [ "$ENI_STATUS" = "available" ]; then
                echo "Deleting available ENI: $ENI"
                aws ec2 delete-network-interface --network-interface-id $ENI 2>/dev/null || echo "Failed to delete ENI $ENI"
              else
                echo "ENI $ENI is $ENI_STATUS, waiting..."
              fi
            done
            
            echo "‚è≥ Waiting additional 30 seconds for ENI cleanup..."
            sleep 30
          fi
          
          # Step 4: Try to delete security group with retries
          echo "üõ°Ô∏è Attempting to delete security group: $SG_ID"
          RETRY_COUNT=0
          MAX_RETRIES=5
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if aws ec2 delete-security-group --group-id $SG_ID 2>/dev/null; then
              echo "‚úÖ Security group deleted successfully"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "‚ö†Ô∏è Attempt $RETRY_COUNT failed, retrying in 30 seconds..."
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                sleep 30
              fi
            fi
          done
          
          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "‚ùå Failed to delete security group after $MAX_RETRIES attempts"
            echo "Manual cleanup may be required in AWS console"
            echo "Security Group ID: $SG_ID"
          fi
        else
          echo "‚ÑπÔ∏è Security group not found or already deleted"
        fi
        
        # Step 5: Clean up IAM resources (optional)
        echo "üîê Cleaning up IAM resources..."
        ROLE_NAME="FinBERT-RAG-EC2-SSM-Role"
        PROFILE_NAME="FinBERT-RAG-EC2-Profile"
        
        # Remove role from instance profile
        aws iam remove-role-from-instance-profile --instance-profile-name $PROFILE_NAME --role-name $ROLE_NAME 2>/dev/null || echo "‚ÑπÔ∏è Role not in instance profile"
        
        # Delete instance profile
        aws iam delete-instance-profile --instance-profile-name $PROFILE_NAME 2>/dev/null || echo "‚ÑπÔ∏è Instance profile not found"
        
        # Detach policies and delete role
        aws iam detach-role-policy --role-name $ROLE_NAME --policy-arn arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore 2>/dev/null || echo "‚ÑπÔ∏è Policy not attached"
        aws iam delete-role --role-name $ROLE_NAME 2>/dev/null || echo "‚ÑπÔ∏è IAM role not found"
        
        echo "‚úÖ IAM cleanup completed"
        
        # Note: Elastic IP and Key pairs are preserved for reuse
        echo ""
        echo "üéâ Infrastructure destruction completed!"
        echo "üìã Preserved resources:"
        echo "- Elastic IP (for reuse)"
        echo "- SSH Key Pairs (for reuse)"
        echo "- VPC and default resources"