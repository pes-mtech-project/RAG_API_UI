# üîß INFRASTRUCTURE SETUP WORKFLOW
name: Setup AWS Infrastructure

on:
  workflow_dispatch:
    inputs:
      destroy:
        description: 'Destroy infrastructure'
        required: false
        default: 'false'
        type: boolean

env:
  AWS_REGION: ap-south-1
  
jobs:
  infrastructure:
    runs-on: ubuntu-latest
    name: üèóÔ∏è Manage AWS Infrastructure
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      
    - name: üîê Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: üîß Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.6.0
        
    - name: üèóÔ∏è Create infrastructure
      if: ${{ !inputs.destroy }}
      run: |
        # Create infrastructure setup script
        cat > setup_infrastructure.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "üèóÔ∏è Setting up AWS infrastructure for FinBERT RAG App in ap-south-1..."
        
        # Set target region
        export AWS_DEFAULT_REGION=ap-south-1
        echo "üåè Working in ap-south-1 region"
        
        # Cleanup any existing terminated instances
        echo "üßπ Cleaning up terminated instances..."
        TERMINATED_INSTANCES=$(aws ec2 describe-instances --filters "Name=instance-state-name,Values=terminated" --query 'Reservations[*].Instances[*].InstanceId' --output text 2>/dev/null || echo "")
        if [ -n "$TERMINATED_INSTANCES" ]; then
          echo "Found terminated instances, they will be cleaned up automatically by AWS"
        fi
        if [ -n "$EXISTING_INSTANCE" ] && [ "$EXISTING_INSTANCE" != "None" ]; then
          echo "üõë Terminating existing instance: $EXISTING_INSTANCE"
          aws ec2 terminate-instances --instance-ids $EXISTING_INSTANCE
          echo "‚è≥ Waiting for instance termination..."
          aws ec2 wait instance-terminated --instance-ids $EXISTING_INSTANCE
          echo "‚úÖ Instance terminated"
        fi
        
        # Switch to ap-south-1
        export AWS_DEFAULT_REGION=ap-south-1
        echo "üåè Switched to ap-south-1 region"
        
        # Check available free tier instance types
        echo "üîç Checking free tier eligible instance types in ap-south-1..."
        aws ec2 describe-instance-types --filters Name=free-tier-eligible,Values=true --query 'InstanceTypes[].InstanceType' --output text || echo "Could not check free tier types"
        
        # Setup SSH key pair
        KEY_NAME="finbert-rag-key-new"
        echo "üîë Setting up SSH key pair..."
        
        # Check if key already exists
        if aws ec2 describe-key-pairs --key-names $KEY_NAME >/dev/null 2>&1; then
          echo "‚úÖ SSH key pair already exists: $KEY_NAME"
        else
          # Create new key pair since import might fail
          echo "üÜï Creating new SSH key pair..."
          aws ec2 create-key-pair --key-name $KEY_NAME --query 'KeyMaterial' --output text > finbert-rag-key-new.pem
          chmod 600 finbert-rag-key-new.pem
          echo "‚úÖ SSH key pair created: $KEY_NAME"
          
          # Store key in GitHub secrets for future use
          echo "üíæ Key pair created successfully"
        fi
        
        # Setup IAM role for EC2 with SSM permissions (optional)
        echo "üîê Setting up IAM role for SSM access..."
        
        ROLE_NAME="FinBERT-RAG-EC2-SSM-Role"
        PROFILE_NAME="FinBERT-RAG-EC2-Profile"
        
        # Check if IAM operations are allowed
        if aws iam get-user >/dev/null 2>&1; then
          echo "‚úÖ IAM access available, creating role..."
          
          # Create trust policy for EC2
          cat > trust-policy.json << 'TRUST_EOF'
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "ec2.amazonaws.com"
              },
              "Action": "sts:AssumeRole"
            }
          ]
        }
        TRUST_EOF
          
          # Try to create IAM role
          if aws iam create-role --role-name $ROLE_NAME --assume-role-policy-document file://trust-policy.json >/dev/null 2>&1; then
            echo "‚úÖ IAM role created"
          else
            echo "‚ÑπÔ∏è IAM role already exists or creation failed"
          fi
          
          # Try to attach SSM policy
          aws iam attach-role-policy --role-name $ROLE_NAME --policy-arn arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore >/dev/null 2>&1 || echo "‚ÑπÔ∏è SSM policy attachment skipped"
          
          # Try to create instance profile
          aws iam create-instance-profile --instance-profile-name $PROFILE_NAME >/dev/null 2>&1 || echo "‚ÑπÔ∏è Instance profile exists"
          aws iam add-role-to-instance-profile --instance-profile-name $PROFILE_NAME --role-name $ROLE_NAME >/dev/null 2>&1 || echo "‚ÑπÔ∏è Role already in profile"
          
          echo "‚úÖ IAM setup completed"
        else
          echo "‚ö†Ô∏è No IAM access - proceeding without SSM role (will use SSH only)"
          PROFILE_NAME=""
        fi
        
        # Create security group
        SG_NAME="finbert-rag-sg"
        VPC_ID=$(aws ec2 describe-vpcs --filters "Name=isDefault,Values=true" --query 'Vpcs[0].VpcId' --output text)
        
        # Check if security group exists
        SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=$SG_NAME" --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "")
        
        if [ -z "$SG_ID" ] || [ "$SG_ID" = "None" ]; then
          echo "üõ°Ô∏è Creating Security Group..."
          SG_ID=$(aws ec2 create-security-group \
            --group-name $SG_NAME \
            --description "Security group for FinBERT RAG App" \
            --vpc-id $VPC_ID \
            --query 'GroupId' --output text)
          
          echo "‚úÖ Security group created: $SG_ID"
          
          # Add security group rules
          echo "üîß Adding security group rules..."
          aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port 22 --cidr 0.0.0.0/0
          aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port 80 --cidr 0.0.0.0/0  
          aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port 443 --cidr 0.0.0.0/0
          aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port 8000 --cidr 0.0.0.0/0
          aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port 8501 --cidr 0.0.0.0/0
          echo "‚úÖ Security group rules added"
        else
          echo "‚úÖ Security group already exists: $SG_ID"
        fi
        
        # Launch EC2 instance
        INSTANCE_NAME="finbert-rag-instance"
        if ! aws ec2 describe-instances --filters "Name=tag:Name,Values=$INSTANCE_NAME" "Name=instance-state-name,Values=running" --query 'Reservations[0].Instances[0].InstanceId' --output text | grep -v "None" >/dev/null 2>&1; then
          echo "üöÄ Launching EC2 instance..."
          
          # User data script for instance initialization (minimal for reliability)
          cat > user_data.sh << 'USERDATA'
        #!/bin/bash
        # Minimal user data to avoid boot failures
        yum update -y
        yum install -y python3.11 python3.11-pip git
        
        # Create log file for debugging
        echo "$(date): User data script started" >> /var/log/user-data.log
        
        # Basic Python setup
        python3.11 -m pip install --upgrade pip
        
        # Create app directory
        mkdir -p /home/ec2-user/finbert-news-rag-app
        chown -R ec2-user:ec2-user /home/ec2-user/
        
        echo "$(date): User data script completed" >> /var/log/user-data.log
        USERDATA
          
          # Get the latest Amazon Linux 2023 AMI for the current region
          AMI_ID=$(aws ec2 describe-images \
            --owners amazon \
            --filters 'Name=name,Values=al2023-ami-*-x86_64' 'Name=state,Values=available' \
            --query 'Images | sort_by(@, &CreationDate) | [-1].ImageId' \
            --output text)
          
          echo "üîç Using AMI: $AMI_ID in region: $(aws configure get region)"
          
          # Try t2.micro first
          INSTANCE_TYPE="t2.micro"
          echo "üöÄ Attempting to launch $INSTANCE_TYPE instance..."
          
          set +e  # Allow command to fail
          
          # Build instance launch command
          LAUNCH_CMD="aws ec2 run-instances --image-id $AMI_ID --count 1 --instance-type $INSTANCE_TYPE --key-name $KEY_NAME --security-group-ids $SG_ID"
          if [ -n "$PROFILE_NAME" ]; then
            LAUNCH_CMD="$LAUNCH_CMD --iam-instance-profile Name=$PROFILE_NAME"
          fi
          LAUNCH_CMD="$LAUNCH_CMD --user-data file://user_data.sh --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value='$INSTANCE_NAME'}]' --query 'Instances[0].InstanceId' --output text"
          
          echo "üöÄ Launching instance with command: $LAUNCH_CMD"
          INSTANCE_ID=$(eval $LAUNCH_CMD 2>/dev/null)
          
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "‚ö†Ô∏è t2.micro failed, trying t3.micro..."
            INSTANCE_TYPE="t3.micro"
            LAUNCH_CMD="aws ec2 run-instances --image-id $AMI_ID --count 1 --instance-type $INSTANCE_TYPE --key-name $KEY_NAME --security-group-ids $SG_ID"
            if [ -n "$PROFILE_NAME" ]; then
              LAUNCH_CMD="$LAUNCH_CMD --iam-instance-profile Name=$PROFILE_NAME"
            fi
            LAUNCH_CMD="$LAUNCH_CMD --user-data file://user_data.sh --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value='$INSTANCE_NAME'}]' --query 'Instances[0].InstanceId' --output text"
            
            INSTANCE_ID=$(eval $LAUNCH_CMD)
          fi
          set -e  # Re-enable exit on error
          
          # Validate instance creation
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ] || [ "$INSTANCE_ID" = "null" ]; then
            echo "‚ùå Failed to launch EC2 instance"
            echo "This could be due to:"
            echo "1. No available capacity in the region"  
            echo "2. Insufficient permissions"
            echo "3. Security group or VPC issues"
            exit 1
          fi
          
          echo "‚úÖ Instance launched successfully!"
          echo "Instance Type: $INSTANCE_TYPE"
          echo "Instance ID: $INSTANCE_ID"
          
          # Wait for instance to be running (with timeout)
          echo "‚è≥ Waiting for instance to be running..."
          if ! timeout 300 aws ec2 wait instance-running --instance-ids $INSTANCE_ID; then
            echo "‚ùå Instance failed to start within 5 minutes"
            echo "Instance may have failed to boot. Check the AWS console for details."
            exit 1
          fi
          
          echo "‚úÖ Instance is now running!"
          
          # Get or create Elastic IP
          echo "üåê Setting up Elastic IP..."
          
          # Check for existing unassigned Elastic IP
          EXISTING_EIP=$(aws ec2 describe-addresses --filters "Name=domain,Values=vpc" --query 'Addresses[?InstanceId==null][0].AllocationId' --output text 2>/dev/null || echo "")
          
          if [ -n "$EXISTING_EIP" ] && [ "$EXISTING_EIP" != "None" ]; then
            echo "‚úÖ Found existing unassigned Elastic IP: $EXISTING_EIP"
            ALLOCATION_ID=$EXISTING_EIP
            ELASTIC_IP=$(aws ec2 describe-addresses --allocation-ids $ALLOCATION_ID --query 'Addresses[0].PublicIp' --output text)
          else
            echo "üÜï Creating new Elastic IP..."
            ALLOCATION_ID=$(aws ec2 allocate-address --domain vpc --query 'AllocationId' --output text)
            ELASTIC_IP=$(aws ec2 describe-addresses --allocation-ids $ALLOCATION_ID --query 'Addresses[0].PublicIp' --output text)
            echo "‚úÖ Created new Elastic IP: $ELASTIC_IP ($ALLOCATION_ID)"
          fi
          
          # Associate Elastic IP with instance
          echo "üîó Associating Elastic IP with instance..."
          ASSOCIATION_ID=$(aws ec2 associate-address --instance-id $INSTANCE_ID --allocation-id $ALLOCATION_ID --query 'AssociationId' --output text)
          echo "‚úÖ Elastic IP associated: $ASSOCIATION_ID"
          
          # Get final public IP (should be the Elastic IP)
          PUBLIC_IP=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
          echo "üåê Instance Public IP (Elastic): $PUBLIC_IP"
          
          # Final validation
          echo "ÔøΩ Performing final validation..."
          INSTANCE_STATE=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query 'Reservations[0].Instances[0].State.Name' --output text)
          if [ "$INSTANCE_STATE" != "running" ]; then
            echo "‚ùå Instance is not in running state: $INSTANCE_STATE"
            exit 1
          fi
          
          # Test basic connectivity (port 22)
          echo "üîç Testing basic connectivity to port 22..."
          if timeout 10 bash -c "</dev/tcp/$PUBLIC_IP/22" 2>/dev/null; then
            echo "‚úÖ Port 22 is accessible"
          else
            echo "‚ö†Ô∏è Port 22 not accessible yet (instance may still be booting)"
          fi
          
          echo "ÔøΩüìã IMPORTANT: Add these to your GitHub Secrets:"
          echo "EC2_INSTANCE_ID=$INSTANCE_ID"
          echo "EC2_HOST=$PUBLIC_IP"
          echo "ELASTIC_IP_ALLOCATION_ID=$ALLOCATION_ID"
          echo ""
          echo "üéØ Instance Details:"
          echo "Region: ap-south-1 (Mumbai)"
          echo "Instance ID: $INSTANCE_ID"
          echo "Instance Type: $INSTANCE_TYPE"
          echo "Elastic IP: $PUBLIC_IP"
          echo "Allocation ID: $ALLOCATION_ID"
          echo "SSH Key: $KEY_NAME"
          
        else
          INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=$INSTANCE_NAME" "Name=instance-state-name,Values=running" --query 'Reservations[0].Instances[0].InstanceId' --output text)
          PUBLIC_IP=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
          echo "‚úÖ Instance already running: $INSTANCE_ID"
          echo "üåê Instance Public IP: $PUBLIC_IP"
        fi
        
        # Create Application Load Balancer (optional, for production)
        # This would go here if needed for higher availability
        
        echo "üéâ Infrastructure setup completed!"
        echo ""
        echo "üìã Next steps:"
        echo "1. Add EC2_INSTANCE_ID=$INSTANCE_ID to GitHub Secrets"
        echo "2. Add EC2_HOST=$PUBLIC_IP to GitHub Secrets"  
        echo "3. Add your private key to EC2_SSH_PRIVATE_KEY secret"
        echo "4. Run the deployment workflow"
        echo ""
        echo "üîó Access URLs (after deployment):"
        echo "API: http://$PUBLIC_IP/api/docs"
        echo "Streamlit: http://$PUBLIC_IP/"
        echo "Direct API: http://$PUBLIC_IP:8000/docs"
        echo "Direct Streamlit: http://$PUBLIC_IP:8501"
        EOF
        
        chmod +x setup_infrastructure.sh
        ./setup_infrastructure.sh
        
    - name: üßπ Destroy infrastructure
      if: ${{ inputs.destroy }}
      run: |
        echo "üßπ Destroying AWS infrastructure..."
        
        # Get instance ID
        INSTANCE_NAME="finbert-rag-instance"
        INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=$INSTANCE_NAME" --query 'Reservations[0].Instances[0].InstanceId' --output text)
        
        if [ "$INSTANCE_ID" != "None" ] && [ -n "$INSTANCE_ID" ]; then
          echo "üõë Terminating EC2 instance: $INSTANCE_ID"
          aws ec2 terminate-instances --instance-ids $INSTANCE_ID
          aws ec2 wait instance-terminated --instance-ids $INSTANCE_ID
          echo "‚úÖ Instance terminated"
        fi
        
        # Clean up security group
        SG_NAME="finbert-rag-sg"
        SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=$SG_NAME" --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "")
        if [ -n "$SG_ID" ] && [ "$SG_ID" != "None" ]; then
          echo "üõ°Ô∏è Deleting security group: $SG_ID"
          aws ec2 delete-security-group --group-id $SG_ID
          echo "‚úÖ Security group deleted"
        fi
        
        # Note: Key pair is kept for reuse
        echo "üéâ Infrastructure cleanup completed!"