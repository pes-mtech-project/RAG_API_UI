# ğŸ”§ INFRASTRUCTURE SETUP WORKFLOW
name: Setup AWS Infrastructure

on:
  workflow_dispatch:
    inputs:
      destroy:
        description: 'Destroy infrastructure'
        required: false
        default: 'false'
        type: boolean

env:
  AWS_REGION: ap-south-1
  
jobs:
  infrastructure:
    runs-on: ubuntu-latest
    name: ğŸ—ï¸ Manage AWS Infrastructure
    
    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4
      
    - name: ğŸ” Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: ğŸ”§ Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.6.0
        
    - name: ğŸ—ï¸ Create infrastructure
      if: ${{ !inputs.destroy }}
      run: |
        # Create infrastructure setup script
        cat > setup_infrastructure.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "ğŸ—ï¸ Setting up AWS infrastructure for FinBERT RAG App in ap-south-1..."
        
        # Cleanup any existing instances in us-east-1 first
        echo "ğŸ§¹ Cleaning up existing instances in us-east-1..."
        export AWS_DEFAULT_REGION=us-east-1
        EXISTING_INSTANCE=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=finbert-rag-instance" "Name=instance-state-name,Values=running,pending" --query 'Reservations[0].Instances[0].InstanceId' --output text 2>/dev/null || echo "")
        if [ -n "$EXISTING_INSTANCE" ] && [ "$EXISTING_INSTANCE" != "None" ]; then
          echo "ğŸ›‘ Terminating existing instance: $EXISTING_INSTANCE"
          aws ec2 terminate-instances --instance-ids $EXISTING_INSTANCE
          echo "â³ Waiting for instance termination..."
          aws ec2 wait instance-terminated --instance-ids $EXISTING_INSTANCE
          echo "âœ… Instance terminated"
        fi
        
        # Switch to ap-south-1
        export AWS_DEFAULT_REGION=ap-south-1
        echo "ğŸŒ Switched to ap-south-1 region"
        
        # Check available free tier instance types
        echo "ğŸ” Checking free tier eligible instance types in ap-south-1..."
        aws ec2 describe-instance-types --filters Name=free-tier-eligible,Values=true --query 'InstanceTypes[].InstanceType' --output text || echo "Could not check free tier types"
        
        # Import existing SSH key pair
        KEY_NAME="finbert-rag-key-new"
        echo "ğŸ”‘ Setting up SSH key pair..."
        
        # Delete existing key if it exists
        aws ec2 delete-key-pair --key-name $KEY_NAME 2>/dev/null || true
        
        # Import the public key from our existing key pair
        echo "ï¿½ Importing SSH public key..."
        aws ec2 import-key-pair \
          --key-name $KEY_NAME \
          --public-key-material "${{ secrets.SSH_PUBLIC_KEY }}"
        
        echo "âœ… SSH key pair imported: $KEY_NAME"
        
        # Create IAM role for EC2 with SSM permissions
        echo "ğŸ” Creating IAM role for EC2..."
        
        # Create trust policy for EC2
        cat > trust-policy.json << 'EOF'
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "ec2.amazonaws.com"
              },
              "Action": "sts:AssumeRole"
            }
          ]
        }
        EOF
        
        # Create IAM role
        ROLE_NAME="FinBERT-RAG-EC2-SSM-Role"
        aws iam create-role \
          --role-name $ROLE_NAME \
          --assume-role-policy-document file://trust-policy.json 2>/dev/null || \
          echo "IAM role already exists"
        
        # Attach SSM managed policy
        aws iam attach-role-policy \
          --role-name $ROLE_NAME \
          --policy-arn arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore 2>/dev/null || \
          echo "SSM policy already attached"
        
        # Create instance profile
        PROFILE_NAME="FinBERT-RAG-EC2-Profile"
        aws iam create-instance-profile \
          --instance-profile-name $PROFILE_NAME 2>/dev/null || \
          echo "Instance profile already exists"
        
        # Add role to instance profile
        aws iam add-role-to-instance-profile \
          --instance-profile-name $PROFILE_NAME \
          --role-name $ROLE_NAME 2>/dev/null || \
          echo "Role already added to instance profile"
        
        echo "âœ… IAM role and instance profile ready"
        
        # Create security group
        SG_NAME="finbert-rag-sg"
        VPC_ID=$(aws ec2 describe-vpcs --filters "Name=isDefault,Values=true" --query 'Vpcs[0].VpcId' --output text)
        
        # Check if security group exists
        SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=$SG_NAME" --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "")
        
        if [ -z "$SG_ID" ] || [ "$SG_ID" = "None" ]; then
          echo "ğŸ›¡ï¸ Creating Security Group..."
          SG_ID=$(aws ec2 create-security-group \
            --group-name $SG_NAME \
            --description "Security group for FinBERT RAG App" \
            --vpc-id $VPC_ID \
            --query 'GroupId' --output text)
          
          echo "âœ… Security group created: $SG_ID"
          
          # Add security group rules
          echo "ğŸ”§ Adding security group rules..."
          aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port 22 --cidr 0.0.0.0/0
          aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port 80 --cidr 0.0.0.0/0  
          aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port 443 --cidr 0.0.0.0/0
          aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port 8000 --cidr 0.0.0.0/0
          aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port 8501 --cidr 0.0.0.0/0
          echo "âœ… Security group rules added"
        else
          echo "âœ… Security group already exists: $SG_ID"
        fi
        
        # Launch EC2 instance
        INSTANCE_NAME="finbert-rag-instance"
        if ! aws ec2 describe-instances --filters "Name=tag:Name,Values=$INSTANCE_NAME" "Name=instance-state-name,Values=running" --query 'Reservations[0].Instances[0].InstanceId' --output text | grep -v "None" >/dev/null 2>&1; then
          echo "ğŸš€ Launching EC2 instance..."
          
          # User data script for instance initialization
          cat > user_data.sh << 'USERDATA'
        #!/bin/bash
        yum update -y
        yum install -y python3.11 python3.11-pip git nginx
        
        # Install additional dependencies
        python3.11 -m pip install --upgrade pip
        
        # Create application user
        useradd -m -s /bin/bash appuser || true
        
        # Clone the repository (will be updated via CI/CD)
        cd /home/ec2-user
        git clone https://github.com/pes-mtech-project/RAG_API_UI.git finbert-news-rag-app || true
        chown -R ec2-user:ec2-user finbert-news-rag-app
        
        # Setup nginx reverse proxy
        cat > /etc/nginx/conf.d/finbert-rag.conf << 'NGINX'
        server {
            listen 80;
            server_name _;
            
            # API routes
            location /api/ {
                proxy_pass http://localhost:8000/;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
            }
            
            # Health check
            location /health {
                proxy_pass http://localhost:8000/health;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
            }
            
            # Streamlit app (default)
            location / {
                proxy_pass http://localhost:8501/;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                
                # WebSocket support for Streamlit
                proxy_http_version 1.1;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection "upgrade";
            }
        }
        NGINX
        
        # Enable and start nginx
        systemctl enable nginx
        systemctl start nginx
        
        echo "âœ… EC2 instance setup completed"
        USERDATA
          
          # Get the latest Amazon Linux 2023 AMI for the current region
          AMI_ID=$(aws ec2 describe-images \
            --owners amazon \
            --filters 'Name=name,Values=al2023-ami-*-x86_64' 'Name=state,Values=available' \
            --query 'Images | sort_by(@, &CreationDate) | [-1].ImageId' \
            --output text)
          
          echo "ğŸ” Using AMI: $AMI_ID in region: $(aws configure get region)"
          
          # Try t2.micro first
          INSTANCE_TYPE="t2.micro"
          echo "ğŸš€ Attempting to launch $INSTANCE_TYPE instance..."
          
          set +e  # Allow command to fail
          INSTANCE_ID=$(aws ec2 run-instances \
            --image-id $AMI_ID \
            --count 1 \
            --instance-type $INSTANCE_TYPE \
            --key-name $KEY_NAME \
            --security-group-ids $SG_ID \
            --iam-instance-profile Name=$PROFILE_NAME \
            --user-data file://user_data.sh \
            --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value='$INSTANCE_NAME'}]' \
            --query 'Instances[0].InstanceId' \
            --output text 2>/dev/null)
          
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "âš ï¸ t2.micro failed, trying t3.micro..."
            INSTANCE_TYPE="t3.micro"
            INSTANCE_ID=$(aws ec2 run-instances \
              --image-id $AMI_ID \
              --count 1 \
              --instance-type $INSTANCE_TYPE \
              --key-name $KEY_NAME \
              --security-group-ids $SG_ID \
              --iam-instance-profile Name=$PROFILE_NAME \
              --user-data file://user_data.sh \
              --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value='$INSTANCE_NAME'}]' \
              --query 'Instances[0].InstanceId' \
              --output text)
          fi
          set -e  # Re-enable exit on error
          
          echo "âœ… Instance launched with type: $INSTANCE_TYPE"
          echo "âœ… Instance ID: $INSTANCE_ID"
          
          echo "âœ… EC2 instance launched: $INSTANCE_ID"
          
          # Wait for instance to be running
          echo "â³ Waiting for instance to be running..."
          aws ec2 wait instance-running --instance-ids $INSTANCE_ID
          
          # Get or create Elastic IP
          echo "ğŸŒ Setting up Elastic IP..."
          
          # Check for existing unassigned Elastic IP
          EXISTING_EIP=$(aws ec2 describe-addresses --filters "Name=domain,Values=vpc" --query 'Addresses[?InstanceId==null][0].AllocationId' --output text 2>/dev/null || echo "")
          
          if [ -n "$EXISTING_EIP" ] && [ "$EXISTING_EIP" != "None" ]; then
            echo "âœ… Found existing unassigned Elastic IP: $EXISTING_EIP"
            ALLOCATION_ID=$EXISTING_EIP
            ELASTIC_IP=$(aws ec2 describe-addresses --allocation-ids $ALLOCATION_ID --query 'Addresses[0].PublicIp' --output text)
          else
            echo "ğŸ†• Creating new Elastic IP..."
            ALLOCATION_ID=$(aws ec2 allocate-address --domain vpc --query 'AllocationId' --output text)
            ELASTIC_IP=$(aws ec2 describe-addresses --allocation-ids $ALLOCATION_ID --query 'Addresses[0].PublicIp' --output text)
            echo "âœ… Created new Elastic IP: $ELASTIC_IP ($ALLOCATION_ID)"
          fi
          
          # Associate Elastic IP with instance
          echo "ğŸ”— Associating Elastic IP with instance..."
          ASSOCIATION_ID=$(aws ec2 associate-address --instance-id $INSTANCE_ID --allocation-id $ALLOCATION_ID --query 'AssociationId' --output text)
          echo "âœ… Elastic IP associated: $ASSOCIATION_ID"
          
          # Get final public IP (should be the Elastic IP)
          PUBLIC_IP=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
          echo "ğŸŒ Instance Public IP (Elastic): $PUBLIC_IP"
          
          echo "ğŸ“‹ IMPORTANT: Add these to your GitHub Secrets:"
          echo "EC2_INSTANCE_ID=$INSTANCE_ID"
          echo "EC2_HOST=$PUBLIC_IP"
          echo "ELASTIC_IP_ALLOCATION_ID=$ALLOCATION_ID"
          echo ""
          echo "ğŸ¯ Instance Details:"
          echo "Region: ap-south-1 (Mumbai)"
          echo "Instance ID: $INSTANCE_ID"
          echo "Instance Type: $INSTANCE_TYPE"
          echo "Elastic IP: $PUBLIC_IP"
          echo "Allocation ID: $ALLOCATION_ID"
          
        else
          INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=$INSTANCE_NAME" "Name=instance-state-name,Values=running" --query 'Reservations[0].Instances[0].InstanceId' --output text)
          PUBLIC_IP=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
          echo "âœ… Instance already running: $INSTANCE_ID"
          echo "ğŸŒ Instance Public IP: $PUBLIC_IP"
        fi
        
        # Create Application Load Balancer (optional, for production)
        # This would go here if needed for higher availability
        
        echo "ğŸ‰ Infrastructure setup completed!"
        echo ""
        echo "ğŸ“‹ Next steps:"
        echo "1. Add EC2_INSTANCE_ID=$INSTANCE_ID to GitHub Secrets"
        echo "2. Add EC2_HOST=$PUBLIC_IP to GitHub Secrets"  
        echo "3. Add your private key to EC2_SSH_PRIVATE_KEY secret"
        echo "4. Run the deployment workflow"
        echo ""
        echo "ğŸ”— Access URLs (after deployment):"
        echo "API: http://$PUBLIC_IP/api/docs"
        echo "Streamlit: http://$PUBLIC_IP/"
        echo "Direct API: http://$PUBLIC_IP:8000/docs"
        echo "Direct Streamlit: http://$PUBLIC_IP:8501"
        EOF
        
        chmod +x setup_infrastructure.sh
        ./setup_infrastructure.sh
        
    - name: ğŸ§¹ Destroy infrastructure
      if: ${{ inputs.destroy }}
      run: |
        echo "ğŸ§¹ Destroying AWS infrastructure..."
        
        # Get instance ID
        INSTANCE_NAME="finbert-rag-instance"
        INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=$INSTANCE_NAME" --query 'Reservations[0].Instances[0].InstanceId' --output text)
        
        if [ "$INSTANCE_ID" != "None" ] && [ -n "$INSTANCE_ID" ]; then
          echo "ğŸ›‘ Terminating EC2 instance: $INSTANCE_ID"
          aws ec2 terminate-instances --instance-ids $INSTANCE_ID
          aws ec2 wait instance-terminated --instance-ids $INSTANCE_ID
          echo "âœ… Instance terminated"
        fi
        
        # Clean up security group
        SG_NAME="finbert-rag-sg"
        SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=$SG_NAME" --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "")
        if [ -n "$SG_ID" ] && [ "$SG_ID" != "None" ]; then
          echo "ğŸ›¡ï¸ Deleting security group: $SG_ID"
          aws ec2 delete-security-group --group-id $SG_ID
          echo "âœ… Security group deleted"
        fi
        
        # Note: Key pair is kept for reuse
        echo "ğŸ‰ Infrastructure cleanup completed!"