name: Development Stack Deployment

on:
  # Disable automatic triggers to save GitHub Actions minutes
  push:
    branches: [ develop ]
  pull_request:
    branches: [ develop ]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even without changes'
        required: false
        default: false
        type: boolean

env:
  # ECR Configuration for Development
  AWS_REGION: ap-south-1
  # ECR_REGISTRY will be computed dynamically from STS identity to avoid cross-account mismatch
  ECR_REGISTRY: ""
  ECR_API_REPOSITORY: finbert-rag/api-dev
  ECR_UI_REPOSITORY: finbert-rag/ui-dev
  
  # ECS Configuration for Development
  ECS_CLUSTER: finbert-rag-dev-cluster
  ECS_SERVICE_API: finbert-api-dev
  ECS_SERVICE_UI: finbert-ui-dev
  ECS_TASK_DEFINITION_API: finbert-api-dev-task
  ECS_TASK_DEFINITION_UI: finbert-ui-dev-task
  
  # Container Configuration
  REGISTRY: ghcr.io
  API_IMAGE_NAME: pes-mtech-project/finbert-api
  UI_IMAGE_NAME: pes-mtech-project/finbert-ui

permissions:
  contents: read
  packages: write
  id-token: write

jobs:
  # ===== CHANGE DETECTION =====
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      api-changed: ${{ steps.changes.outputs.api }}
      ui-changed: ${{ steps.changes.outputs.ui }}
      infrastructure-changed: ${{ steps.changes.outputs.infrastructure }}
      force-deploy: ${{ github.event.inputs.force_deploy == 'true' }}
    steps:
    - name: ðŸ“¥ Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 2

    - name: ðŸ” Detect changes
      id: changes
      run: |
        # Check for API changes
        if git diff --name-only HEAD~1 HEAD | grep -E '^(api/|docker/Dockerfile\.api|requirements\.txt)' > /dev/null || [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
          echo "api=true" >> $GITHUB_OUTPUT
          echo "ðŸ”„ API changes detected - build required"
        else
          echo "api=false" >> $GITHUB_OUTPUT
          echo "âœ… No API changes"
        fi
        
        # Check for UI changes
        if git diff --name-only HEAD~1 HEAD | grep -E '^(streamlit/|docker/Dockerfile\.ui)' > /dev/null || [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
          echo "ui=true" >> $GITHUB_OUTPUT
          echo "ðŸ”„ UI changes detected - build required"
        else
          echo "ui=false" >> $GITHUB_OUTPUT
          echo "âœ… No UI changes"
        fi
        
        # Check for infrastructure changes
        if git diff --name-only HEAD~1 HEAD | grep -E '^(infrastructure/|docker-compose|\.github/workflows/)' > /dev/null || [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
          echo "infrastructure=true" >> $GITHUB_OUTPUT
          echo "ðŸ”„ Infrastructure changes detected"
        else
          echo "infrastructure=false" >> $GITHUB_OUTPUT
          echo "âœ… No infrastructure changes"
        fi

  # ===== CODE QUALITY CHECKS (parallel via matrix, non-blocking) =====
  code-quality:
    runs-on: ubuntu-latest
    name: ðŸ” Code Quality & Security â€¢ ${{ matrix.task }}
    strategy:
      fail-fast: false
      matrix:
        task: [black, isort, flake8, bandit, safety]
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ Set up Python 3.11
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: ðŸ“¦ Install dependencies
        run: |
          pip install --upgrade pip
          pip install flake8 black isort mypy bandit safety

      - name: ðŸŽ¨ Format Check (Black)
        if: matrix.task == 'black'
        run: |
          cd api
          black --check --diff .

      - name: ðŸ“‹ Import Sort Check (isort)
        if: matrix.task == 'isort'
        run: |
          cd api
          isort --check-only --diff .

      - name: ðŸ” Lint Check (Flake8)
        if: matrix.task == 'flake8'
        run: |
          cd api
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
          flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics

      - name: ðŸ›¡ï¸ Security Check (Bandit)
        if: matrix.task == 'bandit'
        run: |
          cd api
          bandit -r . -f json -o bandit-report.json || true
          bandit -r . -ll

      - name: ðŸ”’ Dependency Security Check (Safety)
        if: matrix.task == 'Safety' || matrix.task == 'safety'
        run: |
          cd api
          safety check --json --output safety-report.json || true
          safety check || true

  # ===== DOCKER BUILD & PUSH =====
  build-and-push:
    needs: [detect-changes]
    if: needs.detect-changes.outputs.api-changed == 'true' || needs.detect-changes.outputs.ui-changed == 'true' || needs.detect-changes.outputs.force-deploy == 'true'
    runs-on: ubuntu-latest
    name: ðŸ—ï¸ Build & Push Development Images
    
    steps:
    - name: ðŸ“¥ Checkout repository
      uses: actions/checkout@v4

    - name: ðŸ” Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ðŸ”Ž Determine AWS account and ECR registry
      id: acct
      run: |
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        echo "ACCOUNT_ID=$ACCOUNT_ID" >> $GITHUB_ENV
        echo "ECR_REGISTRY=${ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com" >> $GITHUB_ENV
        echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT

    - name: ðŸ—ï¸ Ensure ECR repositories exist (dev)
      run: |
        set -e
        for REPO in "${{ env.ECR_API_REPOSITORY }}" "${{ env.ECR_UI_REPOSITORY }}"; do
          if aws ecr describe-repositories --repository-names "$REPO" >/dev/null 2>&1; then
            echo "ECR repo exists: $REPO"
          else
            echo "Creating ECR repo: $REPO"
            aws ecr create-repository --repository-name "$REPO" --image-scanning-configuration scanOnPush=true --encryption-configuration encryptionType=AES256 >/dev/null
          fi
        done

    - name: ðŸ”‘ Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: ðŸ·ï¸ Generate build metadata
      id: meta
      run: |
        # Generate version tag for development
        TIMESTAMP=$(date +%Y%m%d-%H%M%S)
        SHORT_SHA=${GITHUB_SHA::8}
        VERSION="dev-${TIMESTAMP}-${SHORT_SHA}"
        
        echo "version=${VERSION}" >> $GITHUB_OUTPUT
        echo "timestamp=${TIMESTAMP}" >> $GITHUB_OUTPUT
        echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
        
        # ECR image URIs
        echo "api_image=${ECR_REGISTRY}/${ECR_API_REPOSITORY}:${VERSION}" >> $GITHUB_OUTPUT
        echo "ui_image=${ECR_REGISTRY}/${ECR_UI_REPOSITORY}:${VERSION}" >> $GITHUB_OUTPUT

    - name: ðŸ”¨ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: ðŸ³ Build and push API image
      if: needs.detect-changes.outputs.api-changed == 'true' || needs.detect-changes.outputs.force-deploy == 'true'
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/Dockerfile.api
        push: true
        tags: |
          ${{ steps.meta.outputs.api_image }}
          ${{ env.ECR_REGISTRY }}/${{ env.ECR_API_REPOSITORY }}:latest-dev
        cache-from: type=gha
        cache-to: type=gha,mode=max

    # UI deployment temporarily disabled while focusing on API-only rollout (UI TD update failing in ECS deploy).
    # - name: ðŸŽ¨ Build and push UI image
    #   if: needs.detect-changes.outputs.ui-changed == 'true' || needs.detect-changes.outputs.force-deploy == 'true'
    #   uses: docker/build-push-action@v5
    #   with:
    #     context: .
    #     file: ./docker/Dockerfile.ui
    #     push: true
    #     tags: |
    #       ${{ steps.meta.outputs.ui_image }}
    #       ${{ env.ECR_REGISTRY }}/${{ env.ECR_UI_REPOSITORY }}:latest-dev
    #     cache-from: type=gha
    #     cache-to: type=gha,mode=max

    - name: ðŸ“‹ Output image information
      run: |
        echo "### ðŸ³ Built Images" >> $GITHUB_STEP_SUMMARY
        echo "| Service | Image URI | Version |" >> $GITHUB_STEP_SUMMARY
        echo "|---------|-----------|---------|" >> $GITHUB_STEP_SUMMARY
        if [[ "${{ needs.detect-changes.outputs.api-changed }}" == "true" || "${{ needs.detect-changes.outputs.force-deploy }}" == "true" ]]; then
          echo "| API | \`${{ steps.meta.outputs.api_image }}\` | \`${{ steps.meta.outputs.version }}\` |" >> $GITHUB_STEP_SUMMARY
        fi
        if [[ "${{ needs.detect-changes.outputs.ui-changed }}" == "true" || "${{ needs.detect-changes.outputs.force-deploy }}" == "true" ]]; then
          echo "| UI | \`${{ steps.meta.outputs.ui_image }}\` | \`${{ steps.meta.outputs.version }}\` |" >> $GITHUB_STEP_SUMMARY
        fi

  # ===== ECS DEPLOYMENT =====
  deploy-to-ecs:
    needs: [detect-changes, build-and-push]
    if: needs.detect-changes.outputs.infrastructure-changed == 'true' || needs.build-and-push.result == 'success'
    runs-on: ubuntu-latest
    name: ðŸš€ Deploy to ECS Development
    
    steps:
    - name: ðŸ“¥ Checkout repository
      uses: actions/checkout@v4

    - name: ðŸ” Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ï¿½ Install jq
      run: sudo apt-get update && sudo apt-get install -y jq

    - name: ï¿½ðŸ”„ Update API task definition (from current service)
      if: needs.detect-changes.outputs.api-changed == 'true' || needs.detect-changes.outputs.force-deploy == 'true'
      run: |
        set -e
        # Discover current task definition ARN on the service
        CURR_TD_ARN=$(aws ecs describe-services \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE_API }} \
          --query 'services[0].taskDefinition' --output text)
        echo "Current API task def: $CURR_TD_ARN"

        # Export the full task definition JSON
        aws ecs describe-task-definition --task-definition "$CURR_TD_ARN" \
          --query taskDefinition > api-task-definition.json

        # Remove fields not accepted on register
        cat api-task-definition.json \
          | jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)' \
          > api-task-def-stripped.json

        # Update image URI in container 0 (assumes single container task)
        NEW_IMAGE="${{ env.ECR_REGISTRY }}/${{ env.ECR_API_REPOSITORY }}:latest-dev"
        jq --arg IMAGE "$NEW_IMAGE" '.containerDefinitions[0].image = $IMAGE' api-task-def-stripped.json > api-task-definition-updated.json

        # Register new task definition revision and capture new ARN
        NEW_TD_ARN=$(aws ecs register-task-definition --cli-input-json file://api-task-definition-updated.json \
          --query 'taskDefinition.taskDefinitionArn' --output text)
        echo "New API task def: $NEW_TD_ARN"

        # Update service to use new TD revision
        aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_SERVICE_API }} --task-definition "$NEW_TD_ARN"

    # UI deployment temporarily disabled while focusing on API-only rollout (UI TD update failing in ECS deploy).
    # - name: ðŸŽ¨ Update UI task definition (from current service)
    #   if: needs.detect-changes.outputs.ui-changed == 'true' || needs.detect-changes.outputs.force-deploy == 'true'
    #   run: |
    #     set -e
    #     CURR_TD_ARN=$(aws ecs describe-services \
    #       --cluster ${{ env.ECS_CLUSTER }} \
    #       --services ${{ env.ECS_SERVICE_UI }} \
    #       --query 'services[0].taskDefinition' --output text)
    #     echo "Current UI task def: $CURR_TD_ARN"
    #     aws ecs describe-task-definition --task-definition "$CURR_TD_ARN" --query taskDefinition > ui-task-definition.json
    #     cat ui-task-definition.json | jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)' > ui-task-def-stripped.json
    #     NEW_IMAGE="${{ env.ECR_REGISTRY }}/${{ env.ECR_UI_REPOSITORY }}:latest-dev"
    #     jq --arg IMAGE "$NEW_IMAGE" '.containerDefinitions[0].image = $IMAGE' ui-task-def-stripped.json > ui-task-definition-updated.json
    #     NEW_TD_ARN=$(aws ecs register-task-definition --cli-input-json file://ui-task-definition-updated.json --query 'taskDefinition.taskDefinitionArn' --output text)
    #     echo "New UI task def: $NEW_TD_ARN"
    #     aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_SERVICE_UI }} --task-definition "$NEW_TD_ARN"

    - name: â³ Wait for deployment completion
      run: |
        echo "ðŸ”„ Waiting for API service to stabilize..."
        aws ecs wait services-stable --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_SERVICE_API }}
        
        echo "âœ… Development deployment completed successfully!"

  # ===== POST-DEPLOYMENT TESTING =====
  test-deployment:
    needs: [deploy-to-ecs]
    runs-on: ubuntu-latest
    name: ðŸ§ª Test Development Deployment
    
    steps:
    - name: ðŸ“¥ Checkout repository
      uses: actions/checkout@v4

    - name: ðŸ” Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ðŸ” Get service endpoints
      id: endpoints
      run: |
        set -e
        # Try to read LoadBalancer DNS from CloudFormation stack outputs
        CFN_DNS=$(aws cloudformation describe-stacks \
          --stack-name FinBertRagDevStack \
          --query 'Stacks[0].Outputs[?OutputKey==`LoadBalancerDNS`].OutputValue' \
          --output text || true)

        if [[ -n "$CFN_DNS" && "$CFN_DNS" != "None" ]]; then
          echo "Using CFN LoadBalancer DNS: $CFN_DNS"
          echo "api_endpoint=http://$CFN_DNS" >> $GITHUB_OUTPUT
        else
          echo "CFN output not found. Falling back to ECS -> ELBv2 discovery"
          TG_ARN=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE_API }} \
            --query 'services[0].loadBalancers[0].targetGroupArn' \
            --output text || true)
          if [[ -n "$TG_ARN" && "$TG_ARN" != "None" ]]; then
            LB_ARN=$(aws elbv2 describe-target-groups --target-group-arns "$TG_ARN" --query 'TargetGroups[0].LoadBalancerArns[0]' --output text || true)
            if [[ -n "$LB_ARN" && "$LB_ARN" != "None" ]]; then
              LB_DNS=$(aws elbv2 describe-load-balancers --load-balancer-arns "$LB_ARN" --query 'LoadBalancers[0].DNSName' --output text || true)
              if [[ -n "$LB_DNS" && "$LB_DNS" != "None" ]]; then
                echo "Discovered ALB DNS: $LB_DNS"
                echo "api_endpoint=http://$LB_DNS" >> $GITHUB_OUTPUT
              else
                echo "api_endpoint=" >> $GITHUB_OUTPUT
              fi
            else
              echo "api_endpoint=" >> $GITHUB_OUTPUT
            fi
          else
            echo "api_endpoint=" >> $GITHUB_OUTPUT
          fi
        fi

    - name: ðŸ¥ Health check API
      if: steps.endpoints.outputs.api_endpoint != ''
      run: |
        API_URL="${{ steps.endpoints.outputs.api_endpoint }}/health"
        echo "ðŸ” Testing API health endpoint: $API_URL"
        
        # Wait for service to be ready (max 5 minutes)
        for i in {1..30}; do
          if curl -f -s "$API_URL" > /dev/null; then
            echo "âœ… API health check passed"
            curl -s "$API_URL" | jq .
            break
          else
            echo "â³ Waiting for API to be ready... (attempt $i/30)"
            sleep 10
          fi
        done

    - name: ðŸ§ª Test API endpoints
      if: steps.endpoints.outputs.api_endpoint != ''
      run: |
        API_BASE="${{ steps.endpoints.outputs.api_endpoint }}"
        
        # Test documentation endpoint
        echo "ðŸ” Testing API documentation..."
        curl -f -s "$API_BASE/docs" > /dev/null && echo "âœ… API docs accessible" || echo "âŒ API docs failed"
        
        # Test search endpoints (expect connection errors without Elasticsearch)
        echo "ðŸ” Testing search endpoints..."
        curl -X POST -H "Content-Type: application/json" \
          -d '{"query": "test", "top_k": 1}' \
          -s "$API_BASE/search/cosine/embedding384d/" | jq . || true

    - name: ðŸ” Validate enhanced embedding search
      if: steps.endpoints.outputs.api_endpoint != ''
      run: |
        set -e
        API_BASE="${{ steps.endpoints.outputs.api_endpoint }}"
        echo "ðŸ” Testing enhanced embedding endpoint..."
        HTTP_CODE=$(curl -s -o search_1155d.json -w "%{http_code}" \
          -X POST "$API_BASE/search/cosine/embedding1155d/" \
          -H "Content-Type: application/json" \
          -d '{"query": "central bank policy impact on inflation expectations", "limit": 1}')
        if [ "$HTTP_CODE" != "200" ]; then
          echo "âŒ embedding1155d endpoint failed with status $HTTP_CODE"
          cat search_1155d.json
          exit 1
        fi
        echo "âœ… embedding1155d endpoint healthy"
        cat search_1155d.json | jq '.results | length'

    - name: ðŸ“Š Generate deployment report
      run: |
        echo "### ðŸš€ Development Deployment Report" >> $GITHUB_STEP_SUMMARY
        echo "| Component | Status | Endpoint |" >> $GITHUB_STEP_SUMMARY
        echo "|-----------|--------|----------|" >> $GITHUB_STEP_SUMMARY
        echo "| API Service | âœ… Deployed | \`${{ steps.endpoints.outputs.api_endpoint || 'Configuring...' }}\` |" >> $GITHUB_STEP_SUMMARY
        echo "| UI Service | âœ… Deployed | \`TBD\` |" >> $GITHUB_STEP_SUMMARY
        echo "| Health Check | âœ… Passed | \`/health\` |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Environment**: Development" >> $GITHUB_STEP_SUMMARY
        echo "**Branch**: \`develop\`" >> $GITHUB_STEP_SUMMARY
        echo "**Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
