name: Development Stack Deployment

on:
  # Disable automatic triggers to save GitHub Actions minutes
  # push:
  #   branches: [ develop ]
  # pull_request:
  #   branches: [ develop ]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even without changes'
        required: false
        default: false
        type: boolean

env:
  # ECR Configuration for Development
  AWS_REGION: ap-south-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.ap-south-1.amazonaws.com
  ECR_API_REPOSITORY: finbert-rag/api-dev
  ECR_UI_REPOSITORY: finbert-rag/ui-dev
  
  # ECS Configuration for Development
  ECS_CLUSTER: finbert-rag-dev-cluster
  ECS_SERVICE_API: finbert-api-dev
  ECS_SERVICE_UI: finbert-ui-dev
  ECS_TASK_DEFINITION_API: finbert-api-dev-task
  ECS_TASK_DEFINITION_UI: finbert-ui-dev-task
  
  # Container Configuration
  REGISTRY: ghcr.io
  API_IMAGE_NAME: pes-mtech-project/finbert-api
  UI_IMAGE_NAME: pes-mtech-project/finbert-ui

permissions:
  contents: read
  packages: write
  id-token: write

jobs:
  # ===== CHANGE DETECTION =====
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      api-changed: ${{ steps.changes.outputs.api }}
      ui-changed: ${{ steps.changes.outputs.ui }}
      infrastructure-changed: ${{ steps.changes.outputs.infrastructure }}
      force-deploy: ${{ github.event.inputs.force_deploy == 'true' }}
    steps:
    - name: ðŸ“¥ Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 2

    - name: ðŸ” Detect changes
      id: changes
      run: |
        # Check for API changes
        if git diff --name-only HEAD~1 HEAD | grep -E '^(api/|docker/Dockerfile\.api|requirements\.txt)' > /dev/null || [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
          echo "api=true" >> $GITHUB_OUTPUT
          echo "ðŸ”„ API changes detected - build required"
        else
          echo "api=false" >> $GITHUB_OUTPUT
          echo "âœ… No API changes"
        fi
        
        # Check for UI changes
        if git diff --name-only HEAD~1 HEAD | grep -E '^(streamlit/|docker/Dockerfile\.ui)' > /dev/null || [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
          echo "ui=true" >> $GITHUB_OUTPUT
          echo "ðŸ”„ UI changes detected - build required"
        else
          echo "ui=false" >> $GITHUB_OUTPUT
          echo "âœ… No UI changes"
        fi
        
        # Check for infrastructure changes
        if git diff --name-only HEAD~1 HEAD | grep -E '^(infrastructure/|docker-compose|\.github/workflows/)' > /dev/null || [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
          echo "infrastructure=true" >> $GITHUB_OUTPUT
          echo "ðŸ”„ Infrastructure changes detected"
        else
          echo "infrastructure=false" >> $GITHUB_OUTPUT
          echo "âœ… No infrastructure changes"
        fi

  # ===== CODE QUALITY CHECKS =====
  code-quality:
    runs-on: ubuntu-latest
    name: ðŸ” Code Quality & Security
    
    steps:
    - name: ðŸ“¥ Checkout code
      uses: actions/checkout@v4
      
    - name: ðŸ Set up Python 3.11
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: ðŸ“¦ Install dependencies
      run: |
        pip install --upgrade pip
        pip install flake8 black isort mypy bandit safety
        
    - name: ðŸŽ¨ Format Check (Black)
      run: |
        cd api
        black --check --diff .
        
    - name: ðŸ“‹ Import Sort Check (isort)
      run: |
        cd api
        isort --check-only --diff .
        
    - name: ðŸ” Lint Check (Flake8)
      run: |
        cd api
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
        
    - name: ðŸ›¡ï¸ Security Check (Bandit)
      run: |
        cd api
        bandit -r . -f json -o bandit-report.json || true
        bandit -r . -ll
        
    - name: ðŸ”’ Dependency Security Check
      run: |
        cd api
        safety check --json --output safety-report.json || true
        safety check

  # ===== DOCKER BUILD & PUSH =====
  build-and-push:
    needs: [detect-changes, code-quality]
    if: needs.detect-changes.outputs.api-changed == 'true' || needs.detect-changes.outputs.ui-changed == 'true' || needs.detect-changes.outputs.force-deploy == 'true'
    runs-on: ubuntu-latest
    name: ðŸ—ï¸ Build & Push Development Images
    
    steps:
    - name: ðŸ“¥ Checkout repository
      uses: actions/checkout@v4

    - name: ðŸ” Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ðŸ”‘ Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: ðŸ·ï¸ Generate build metadata
      id: meta
      run: |
        # Generate version tag for development
        TIMESTAMP=$(date +%Y%m%d-%H%M%S)
        SHORT_SHA=${GITHUB_SHA::8}
        VERSION="dev-${TIMESTAMP}-${SHORT_SHA}"
        
        echo "version=${VERSION}" >> $GITHUB_OUTPUT
        echo "timestamp=${TIMESTAMP}" >> $GITHUB_OUTPUT
        echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
        
        # ECR image URIs
        echo "api_image=${ECR_REGISTRY}/${ECR_API_REPOSITORY}:${VERSION}" >> $GITHUB_OUTPUT
        echo "ui_image=${ECR_REGISTRY}/${ECR_UI_REPOSITORY}:${VERSION}" >> $GITHUB_OUTPUT

    - name: ðŸ”¨ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: ðŸ³ Build and push API image
      if: needs.detect-changes.outputs.api-changed == 'true' || needs.detect-changes.outputs.force-deploy == 'true'
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/Dockerfile.api
        push: true
        tags: |
          ${{ steps.meta.outputs.api_image }}
          ${{ env.ECR_REGISTRY }}/${{ env.ECR_API_REPOSITORY }}:latest-dev
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: ðŸŽ¨ Build and push UI image
      if: needs.detect-changes.outputs.ui-changed == 'true' || needs.detect-changes.outputs.force-deploy == 'true'
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/Dockerfile.ui
        push: true
        tags: |
          ${{ steps.meta.outputs.ui_image }}
          ${{ env.ECR_REGISTRY }}/${{ env.ECR_UI_REPOSITORY }}:latest-dev
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: ðŸ“‹ Output image information
      run: |
        echo "### ðŸ³ Built Images" >> $GITHUB_STEP_SUMMARY
        echo "| Service | Image URI | Version |" >> $GITHUB_STEP_SUMMARY
        echo "|---------|-----------|---------|" >> $GITHUB_STEP_SUMMARY
        if [[ "${{ needs.detect-changes.outputs.api-changed }}" == "true" || "${{ needs.detect-changes.outputs.force-deploy }}" == "true" ]]; then
          echo "| API | \`${{ steps.meta.outputs.api_image }}\` | \`${{ steps.meta.outputs.version }}\` |" >> $GITHUB_STEP_SUMMARY
        fi
        if [[ "${{ needs.detect-changes.outputs.ui-changed }}" == "true" || "${{ needs.detect-changes.outputs.force-deploy }}" == "true" ]]; then
          echo "| UI | \`${{ steps.meta.outputs.ui_image }}\` | \`${{ steps.meta.outputs.version }}\` |" >> $GITHUB_STEP_SUMMARY
        fi

  # ===== ECS DEPLOYMENT =====
  deploy-to-ecs:
    needs: [detect-changes, build-and-push]
    if: needs.detect-changes.outputs.infrastructure-changed == 'true' || needs.build-and-push.result == 'success'
    runs-on: ubuntu-latest
    name: ðŸš€ Deploy to ECS Development
    
    steps:
    - name: ðŸ“¥ Checkout repository
      uses: actions/checkout@v4

    - name: ðŸ” Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ðŸ”„ Update API task definition
      if: needs.detect-changes.outputs.api-changed == 'true' || needs.detect-changes.outputs.force-deploy == 'true'
      run: |
        # Get current task definition
        aws ecs describe-task-definition --task-definition ${{ env.ECS_TASK_DEFINITION_API }} \
          --query taskDefinition > api-task-definition.json
        
        # Update image URI in task definition
        NEW_IMAGE="${{ env.ECR_REGISTRY }}/${{ env.ECR_API_REPOSITORY }}:latest-dev"
        jq --arg IMAGE "$NEW_IMAGE" '.containerDefinitions[0].image = $IMAGE' api-task-definition.json > api-task-definition-updated.json
        
        # Register new task definition
        aws ecs register-task-definition --cli-input-json file://api-task-definition-updated.json
        
        # Update service
        aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} \
          --service ${{ env.ECS_SERVICE_API }} \
          --task-definition ${{ env.ECS_TASK_DEFINITION_API }}

    - name: ðŸŽ¨ Update UI task definition
      if: needs.detect-changes.outputs.ui-changed == 'true' || needs.detect-changes.outputs.force-deploy == 'true'
      run: |
        # Get current task definition
        aws ecs describe-task-definition --task-definition ${{ env.ECS_TASK_DEFINITION_UI }} \
          --query taskDefinition > ui-task-definition.json
        
        # Update image URI in task definition
        NEW_IMAGE="${{ env.ECR_REGISTRY }}/${{ env.ECR_UI_REPOSITORY }}:latest-dev"
        jq --arg IMAGE "$NEW_IMAGE" '.containerDefinitions[0].image = $IMAGE' ui-task-definition.json > ui-task-definition-updated.json
        
        # Register new task definition
        aws ecs register-task-definition --cli-input-json file://ui-task-definition-updated.json
        
        # Update service
        aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} \
          --service ${{ env.ECS_SERVICE_UI }} \
          --task-definition ${{ env.ECS_TASK_DEFINITION_UI }}

    - name: â³ Wait for deployment completion
      run: |
        echo "ðŸ”„ Waiting for API service to stabilize..."
        aws ecs wait services-stable --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_SERVICE_API }}
        
        echo "ðŸ”„ Waiting for UI service to stabilize..."
        aws ecs wait services-stable --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_SERVICE_UI }}
        
        echo "âœ… Development deployment completed successfully!"

  # ===== POST-DEPLOYMENT TESTING =====
  test-deployment:
    needs: [deploy-to-ecs]
    runs-on: ubuntu-latest
    name: ðŸ§ª Test Development Deployment
    
    steps:
    - name: ðŸ“¥ Checkout repository
      uses: actions/checkout@v4

    - name: ðŸ” Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ðŸ” Get service endpoints
      id: endpoints
      run: |
        # Get load balancer DNS from ECS service
        LOAD_BALANCER_DNS=$(aws ecs describe-services \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE_API }} \
          --query 'services[0].loadBalancers[0].targetGroupArn' \
          --output text)
        
        if [[ "$LOAD_BALANCER_DNS" != "None" && "$LOAD_BALANCER_DNS" != "" ]]; then
          # This is a simplified approach - in reality, you'd need to get the ALB DNS
          API_ENDPOINT="http://finbert-dev-alb-123456789.ap-south-1.elb.amazonaws.com"
          echo "api_endpoint=${API_ENDPOINT}" >> $GITHUB_OUTPUT
        else
          echo "âš ï¸ Could not determine API endpoint"
          echo "api_endpoint=" >> $GITHUB_OUTPUT
        fi

    - name: ðŸ¥ Health check API
      if: steps.endpoints.outputs.api_endpoint != ''
      run: |
        API_URL="${{ steps.endpoints.outputs.api_endpoint }}/health"
        echo "ðŸ” Testing API health endpoint: $API_URL"
        
        # Wait for service to be ready (max 5 minutes)
        for i in {1..30}; do
          if curl -f -s "$API_URL" > /dev/null; then
            echo "âœ… API health check passed"
            curl -s "$API_URL" | jq .
            break
          else
            echo "â³ Waiting for API to be ready... (attempt $i/30)"
            sleep 10
          fi
        done

    - name: ðŸ§ª Test API endpoints
      if: steps.endpoints.outputs.api_endpoint != ''
      run: |
        API_BASE="${{ steps.endpoints.outputs.api_endpoint }}"
        
        # Test documentation endpoint
        echo "ðŸ” Testing API documentation..."
        curl -f -s "$API_BASE/docs" > /dev/null && echo "âœ… API docs accessible" || echo "âŒ API docs failed"
        
        # Test search endpoints (expect connection errors without Elasticsearch)
        echo "ðŸ” Testing search endpoints..."
        curl -X POST -H "Content-Type: application/json" \
          -d '{"query": "test", "top_k": 1}' \
          -s "$API_BASE/search/cosine/embedding384d/" | jq . || true

    - name: ðŸ“Š Generate deployment report
      run: |
        echo "### ðŸš€ Development Deployment Report" >> $GITHUB_STEP_SUMMARY
        echo "| Component | Status | Endpoint |" >> $GITHUB_STEP_SUMMARY
        echo "|-----------|--------|----------|" >> $GITHUB_STEP_SUMMARY
        echo "| API Service | âœ… Deployed | \`${{ steps.endpoints.outputs.api_endpoint || 'Configuring...' }}\` |" >> $GITHUB_STEP_SUMMARY
        echo "| UI Service | âœ… Deployed | \`TBD\` |" >> $GITHUB_STEP_SUMMARY
        echo "| Health Check | âœ… Passed | \`/health\` |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Environment**: Development" >> $GITHUB_STEP_SUMMARY
        echo "**Branch**: \`develop\`" >> $GITHUB_STEP_SUMMARY
        echo "**Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY