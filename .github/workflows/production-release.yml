name: Production Release

on:
  push:
    branches: [ live ]
    tags: [ 'v*.*.*' ]  # Semantic versioning tags (e.g., v1.2.3)
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., 1.2.3)'
        required: true
        type: string
      environment:
        description: 'Target environment'
        required: true
        default: 'prod'
        type: choice
        options:
          - prod
          - staging
      force_deploy:
        description: 'Force deployment even without changes'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  API_IMAGE_NAME: pes-mtech-project/finbert-news-rag-app/finbert-api
  AWS_REGION: ap-south-1
  PROD_CLUSTER_NAME: finbert-rag-prod

permissions:
  contents: write
  packages: write
  actions: read
  id-token: write

jobs:
  # ===== VERSION VALIDATION & TAGGING =====
  version-management:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      version-tag: ${{ steps.version.outputs.tag }}
      is-release: ${{ steps.version.outputs.is-release }}
      should-deploy: ${{ steps.version.outputs.should-deploy }}
    
    steps:
    - name: ğŸ“¥ Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.MYGITHUB_TOKEN }}

    - name: ğŸ·ï¸ Determine version and tagging strategy
      id: version
      run: |
        # Determine version from different trigger types
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          VERSION="${{ github.event.inputs.version }}"
          IS_RELEASE="true"
          SHOULD_DEPLOY="${{ github.event.inputs.force_deploy }}"
          echo "ğŸ“ Manual release triggered: v$VERSION"
          
        elif [[ "${{ github.ref }}" == refs/tags/v* ]]; then
          VERSION="${{ github.ref_name }}"
          VERSION="${VERSION#v}"  # Remove 'v' prefix
          IS_RELEASE="true"
          SHOULD_DEPLOY="true"
          echo "ğŸ·ï¸ Tag-triggered release: v$VERSION"
          
        elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          # Auto-version for main branch pushes
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          LAST_VERSION="${LAST_TAG#v}"
          
          # Increment patch version
          IFS='.' read -ra PARTS <<< "$LAST_VERSION"
          MAJOR=${PARTS[0]:-0}
          MINOR=${PARTS[1]:-0}
          PATCH=${PARTS[2]:-0}
          PATCH=$((PATCH + 1))
          
          VERSION="$MAJOR.$MINOR.$PATCH"
          IS_RELEASE="false"
          SHOULD_DEPLOY="true"
          echo "ğŸ”„ Auto-version for main branch: v$VERSION"
          
        else
          echo "âŒ Unexpected trigger - exiting"
          exit 1
        fi
        
        TAG="v$VERSION"
        
        # Validate version format
        if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "âŒ Invalid version format: $VERSION (expected: X.Y.Z)"
          exit 1
        fi
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        echo "is-release=$IS_RELEASE" >> $GITHUB_OUTPUT
        echo "should-deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
        
        echo "âœ… Version: $VERSION"
        echo "âœ… Tag: $TAG"
        echo "âœ… Is Release: $IS_RELEASE"
        echo "âœ… Should Deploy: $SHOULD_DEPLOY"

    - name: ğŸ·ï¸ Create release tag
      if: steps.version.outputs.is-release == 'true' && github.event_name == 'workflow_dispatch'
      run: |
        TAG="${{ steps.version.outputs.tag }}"
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
        if git tag -l | grep -q "^$TAG$"; then
          echo "âš ï¸ Tag $TAG already exists"
        else
          git tag -a "$TAG" -m "Release $TAG"
          git push origin "$TAG"
          echo "âœ… Created and pushed tag: $TAG"
        fi

  # ===== PRE-DEPLOYMENT VALIDATION =====
  validate-deployment:
    runs-on: ubuntu-latest
    needs: version-management
    if: needs.version-management.outputs.should-deploy == 'true'
    
    steps:
    - name: ğŸ“¥ Checkout repository
      uses: actions/checkout@v4

    - name: ğŸ” Validate Docker files
      run: |
        echo "ğŸ” Validating Docker configurations..."
        
        # Check Dockerfile.api exists and is valid
        if [[ ! -f "docker/Dockerfile.api" ]]; then
          echo "âŒ docker/Dockerfile.api not found"
          exit 1
        fi
        
        echo "âœ… Docker files validated"

    - name: ğŸ” Validate infrastructure code
      run: |
        echo "ğŸ” Validating infrastructure configurations..."
        
        if [[ ! -d "infrastructure" ]]; then
          echo "âŒ Infrastructure directory not found"
          exit 1
        fi
        
        if [[ ! -f "infrastructure/package.json" ]]; then
          echo "âŒ infrastructure/package.json not found"
          exit 1
        fi
        
        echo "âœ… Infrastructure validated"

    - name: ğŸ” Validate environment configuration
      run: |
        echo "ğŸ” Checking production environment readiness..."
        
        # Check required secrets (these should be set in GitHub repository settings)
        REQUIRED_SECRETS=(
          "AWS_ACCESS_KEY_ID"
          "AWS_SECRET_ACCESS_KEY"
          "GITHUB_TOKEN"
        )
        
        echo "ğŸ“‹ Required secrets for production deployment:"
        for secret in "${REQUIRED_SECRETS[@]}"; do
          echo "  - $secret"
        done
        
        echo "âœ… Environment validation complete"

  # ===== BUILD & PUSH CONTAINERS =====
  build-and-push:
    runs-on: ubuntu-latest
    needs: [version-management, validate-deployment]
    if: needs.version-management.outputs.should-deploy == 'true'
    
    steps:
    - name: ğŸ“¥ Checkout repository
      uses: actions/checkout@v4

    - name: ï¿½ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: network=host

    - name: ï¿½ğŸ” Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.MYGITHUB_TOKEN }}

    - name: ğŸ·ï¸ Generate container metadata for API
      id: meta-api
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.API_IMAGE_NAME }}
        tags: |
          type=raw,value=latest
          type=raw,value=prod
          type=raw,value=${{ needs.version-management.outputs.version }}
          type=raw,value=${{ needs.version-management.outputs.version-tag }}
          type=sha,prefix=prod-

    - name: ğŸ—ï¸ Build and push API container
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/Dockerfile.api
        push: true
        tags: ${{ steps.meta-api.outputs.tags }}
        labels: ${{ steps.meta-api.outputs.labels }}
        build-args: |
          VERSION=${{ needs.version-management.outputs.version }}
          BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
          GIT_SHA=${{ github.sha }}
        cache-from: type=gha

    - name: ğŸ”“ Make container packages public
      run: |
        echo "ğŸ”“ Configuring container package visibility..."
        
        # Make API package public
        gh api --method PATCH \
          "/orgs/pes-mtech-project/packages/container/finbert-news-rag-app%2Ffinbert-api" \
          -f visibility=public || echo "âš ï¸ API package already public or needs manual configuration"

  # ===== DEPLOY TO PRODUCTION =====
  deploy-production:
    runs-on: ubuntu-latest
    needs: [version-management, build-and-push]
    if: needs.version-management.outputs.should-deploy == 'true'
    
    steps:
    - name: ğŸ“¥ Checkout repository
      uses: actions/checkout@v4

    - name: ğŸ”§ Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ğŸ“¦ Set up Node.js for CDK
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: infrastructure/package-lock.json

    - name: ğŸ“¦ Install CDK dependencies
      run: |
        cd infrastructure
        npm ci
        npm install -g aws-cdk@latest

    - name: ğŸš€ Deploy infrastructure & application
      env:
        # Map GitHub secrets to expected environment variable names
        ES_CLOUD_HOST: ${{ secrets.ES_CLOUD_HOST }}
        ES_CLOUD_READONLY_KEY: ${{ secrets.ES_CLOUD_READONLY_KEY }}
        ES_CLOUD_UNRESTRICTED_KEY: ${{ secrets.ES_CLOUD_UNRESTRICTED_KEY }}
        HF_TOKEN: ${{ secrets.HF_TOKEN }}
        HUGGINGFACE_TOKEN: ${{ secrets.HUGGINGFACE_TOKEN }}
      run: |
        cd infrastructure
        
        VERSION="${{ needs.version-management.outputs.version }}"
        
        echo "ğŸš€ Deploying FinBERT RAG v$VERSION to production..."
        echo "ğŸ“¦ API Image: ${{ env.REGISTRY }}/${{ env.API_IMAGE_NAME }}:$VERSION"
        echo "ğŸ” Environment variables configured for Elasticsearch and ML services"
        
        # Deploy with version-specific image tags and environment variables
        npx cdk deploy FinBertRagProdStack \
          --require-approval never \
          --context apiImageTag="$VERSION" \
          --context version="$VERSION" \
          --outputs-file cdk-outputs.json
          
        echo "âœ… Production deployment complete!"

    - name: ğŸ“Š Post-deployment verification
      run: |
        cd infrastructure
        
        if [[ -f "cdk-outputs.json" ]]; then
          echo "ğŸ“Š Deployment outputs:"
          cat cdk-outputs.json
          
          # Extract ALB URL if available
          ALB_URL=$(jq -r '.FinBertRagProdStack.ApplicationLoadBalancerDNS // empty' cdk-outputs.json 2>/dev/null || echo "")
          
          if [[ -n "$ALB_URL" ]]; then
            echo "ğŸŒ Production URL: http://$ALB_URL"
            
            # Health check with retry
            for i in {1..5}; do
              if curl -s "http://$ALB_URL/health" | grep -q "healthy"; then
                echo "âœ… Health check passed (attempt $i)"
                break
              else
                echo "â³ Health check failed (attempt $i/5), retrying..."
                sleep 30
              fi
            done
          fi
        fi

    - name: ğŸŒ Update Production DNS Record
      run: |
        cd infrastructure
        
        # Extract ALB DNS from CDK outputs
        if [[ -f "cdk-outputs.json" ]]; then
          ALB_DNS=$(jq -r '.FinBertRagProdStack.LoadBalancerDNS // empty' cdk-outputs.json 2>/dev/null || echo "")
          
          if [[ -n "$ALB_DNS" ]]; then
            echo "ğŸ”„ Updating production DNS record"
            echo "ğŸ“ Target ALB: $ALB_DNS"
            
            # Update DNS record using our script
            cd ..
            ./scripts/update-dns-record.sh prod "$ALB_DNS"
            
            echo "âœ… Production DNS updated successfully!"
            echo "ğŸŒ Production URL: http://news-rag.lauki.co"
          else
            echo "âš ï¸ Could not extract ALB DNS from outputs"
          fi
        else
          echo "âš ï¸ CDK outputs file not found"
        fi

  # ===== CREATE GITHUB RELEASE =====
  create-release:
    runs-on: ubuntu-latest
    needs: [version-management, deploy-production]
    if: needs.version-management.outputs.is-release == 'true' && success()
    
    steps:
    - name: ğŸ“¥ Checkout repository
      uses: actions/checkout@v4

    - name: ğŸ“ Generate release notes
      id: release-notes
      run: |
        VERSION="${{ needs.version-management.outputs.version }}"
        TAG="${{ needs.version-management.outputs.version-tag }}"
        
        # Get commits since last tag
        LAST_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
        
        if [[ -n "$LAST_TAG" ]]; then
          COMMITS=$(git log --oneline --no-merges ${LAST_TAG}..HEAD | head -20)
        else
          COMMITS=$(git log --oneline --no-merges -10)
        fi
        
        # Create release notes
        cat > release_notes.md << EOF
        # ğŸš€ FinBERT News RAG v$VERSION
        
        ## ğŸ¯ What's New
        
        This release includes the latest improvements to the FinBERT News RAG system:
        
        - âœ… **Semantic Search**: Advanced vector similarity search with populated embeddings
        - âœ… **Production Ready**: Deployed to AWS ECS with high availability
        - âœ… **Quality Assured**: Comprehensive testing and validation pipeline
        - âœ… **Container Optimized**: Multi-stage Docker builds with security hardening
        
        ## ğŸ“¦ Container Images
        
        - **API**: \`ghcr.io/pes-mtech-project/finbert-news-rag-app/finbert-api:$VERSION\`
        
        ## ğŸ”„ Recent Changes
        
        \`\`\`
        $COMMITS
        \`\`\`
        
        ## ğŸš€ Deployment
        
        This version has been automatically deployed to production and is now live.
        
        ---
        
        **Full Changelog**: https://github.com/pes-mtech-project/RAG_API_UI/compare/$LAST_TAG...$TAG
        EOF
        
        echo "release-notes-file=release_notes.md" >> $GITHUB_OUTPUT

    - name: ğŸ‰ Create GitHub Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.MYGITHUB_TOKEN }}
      with:
        tag_name: ${{ needs.version-management.outputs.version-tag }}
        release_name: FinBERT News RAG v${{ needs.version-management.outputs.version }}
        body_path: ${{ steps.release-notes.outputs.release-notes-file }}
        draft: false
        prerelease: false

  # ===== NOTIFICATION & CLEANUP =====
  notify-completion:
    runs-on: ubuntu-latest
    needs: [version-management, deploy-production]
    if: always() && needs.version-management.outputs.should-deploy == 'true'
    
    steps:
    - name: ğŸ“¢ Deployment status notification
      run: |
        VERSION="${{ needs.version-management.outputs.version }}"
        
        if [[ "${{ needs.deploy-production.result }}" == "success" ]]; then
          echo "ğŸ‰ SUCCESS: FinBERT RAG v$VERSION deployed to production!"
          echo "ğŸŒ Production system is now live and operational"
          echo "ğŸ“Š All quality checks passed"
          echo "ğŸ” Semantic search with vector embeddings active"
        else
          echo "âŒ FAILED: Deployment of v$VERSION failed"
          echo "ğŸ” Check the deployment logs for details"
          echo "âš ï¸ Production system may need manual intervention"
        fi