name: ECS - Container Build & Deploy

on:
  push:
    branches: [ develop ]  # Only for development environment
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  API_IMAGE_NAME: pes-mtech-project/finbert-news-rag-app/finbert-api
  AWS_REGION: ap-south-1

permissions:
  contents: read
  packages: write
  actions: read

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      api-changed: ${{ steps.changes.outputs.api }}
      infrastructure-changed: ${{ steps.changes.outputs.infrastructure }}
    steps:
    - name: ðŸ“¥ Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 2

    - name: ðŸ” Detect changes
      id: changes
      run: |
        # Check for API changes (code that affects the container)
        if git diff --name-only HEAD~1 HEAD | grep -E '^(api/|docker/|requirements\.txt|Dockerfile)' > /dev/null; then
          echo "api=true" >> $GITHUB_OUTPUT
          echo "ðŸ”„ API code changes detected - build required"
        else
          echo "api=false" >> $GITHUB_OUTPUT
          echo "âœ… No API code changes - skipping build"
        fi
        
        # Check for infrastructure changes
        if git diff --name-only HEAD~1 HEAD | grep -E '^(infrastructure/|\.github/workflows/)' > /dev/null; then
          echo "infrastructure=true" >> $GITHUB_OUTPUT
          echo "ðŸ”„ Infrastructure changes detected - deployment required"
        else
          echo "infrastructure=false" >> $GITHUB_OUTPUT
          echo "âœ… No infrastructure changes - skipping deployment"
        fi
        
        # Always run on manual trigger or first commit
        if [ "${{ github.event_name }}" = "workflow_dispatch" ] || [ "${{ github.event.before }}" = "0000000000000000000000000000000000000000" ]; then
          echo "api=true" >> $GITHUB_OUTPUT
          echo "infrastructure=true" >> $GITHUB_OUTPUT
          echo "ðŸš€ Manual trigger or initial commit - running all jobs"
        fi

  build-and-push:
    needs: detect-changes
    runs-on: ubuntu-latest
    if: needs.detect-changes.outputs.api-changed == 'true'

    steps:
    - name: ðŸ“¥ Checkout repository
      uses: actions/checkout@v4

    - name: ï¿½ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: network=host

    - name: ï¿½ðŸ” Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.MYGITHUB_TOKEN }}

    - name: ðŸ·ï¸ Extract metadata for API
      id: meta-api
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.API_IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix=sha-
          type=raw,value=develop,enable=${{ github.ref == 'refs/heads/develop' }}

    - name: ðŸ—ï¸ Build and push API Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/Dockerfile.api
        push: true
        tags: ${{ steps.meta-api.outputs.tags }}
        labels: ${{ steps.meta-api.outputs.labels }}
        cache-from: type=gha

    - name: ðŸ”“ Make container package public
      run: |
        # Make the API image package public for ECS access
        gh api --method PATCH /orgs/pes-mtech-project/packages/container/rag_api_ui%2Ffinbert-api \
          --field visibility=public || \
        echo "âš ï¸ Package might already be public or permissions may be needed"
      env:
        GITHUB_TOKEN: ${{ secrets.MYGITHUB_TOKEN }}

  deploy:
    needs: [detect-changes, build-and-push]
    runs-on: ubuntu-latest
    if: always() && (needs.detect-changes.outputs.infrastructure-changed == 'true' || needs.detect-changes.outputs.api-changed == 'true') && (github.event_name == 'push' || github.event_name == 'workflow_dispatch')
    
    steps:
    - name: ðŸ“¥ Checkout repository
      uses: actions/checkout@v4

    - name: âš™ï¸ Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v3
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: ðŸŽ¯ Determine environment
      id: environment
      run: |
        if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          echo "env=prod" >> $GITHUB_OUTPUT
          echo "stack_name=FinBertRagProdStack" >> $GITHUB_OUTPUT
          echo "image_tag=latest" >> $GITHUB_OUTPUT
        else
          echo "env=dev" >> $GITHUB_OUTPUT
          echo "stack_name=FinBertRagDevStack" >> $GITHUB_OUTPUT
          echo "image_tag=develop" >> $GITHUB_OUTPUT
        fi

    - name: ðŸ“¦ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        cache-dependency-path: infrastructure/package-lock.json

    - name: ðŸ“¦ Install CDK dependencies
      working-directory: ./infrastructure
      run: npm ci

    - name: ï¿½ Check and handle stuck CloudFormation stacks
      run: |
        STACK_NAME="${{ steps.environment.outputs.stack_name }}"
        echo "Checking stack status for: $STACK_NAME"
        
        # Check if stack exists and its status
        STACK_STATUS=$(aws cloudformation describe-stacks \
          --stack-name $STACK_NAME \
          --query 'Stacks[0].StackStatus' \
          --output text 2>/dev/null || echo "STACK_NOT_FOUND")
        
        echo "Current stack status: $STACK_STATUS"
        
        if [ "$STACK_STATUS" = "CREATE_IN_PROGRESS" ] || [ "$STACK_STATUS" = "UPDATE_IN_PROGRESS" ]; then
          echo "âš ï¸  Stack is in progress state. Waiting up to 10 minutes for completion..."
          
          # Wait for stack to complete or timeout after 10 minutes
          aws cloudformation wait stack-create-complete \
            --stack-name $STACK_NAME \
            --cli-read-timeout 600 \
            --cli-connect-timeout 60 || \
          aws cloudformation wait stack-update-complete \
            --stack-name $STACK_NAME \
            --cli-read-timeout 600 \
            --cli-connect-timeout 60 || \
          echo "â° Stack operation timed out or failed"
        fi

    - name: ï¿½ðŸš€ Deploy infrastructure with CDK
      working-directory: ./infrastructure
      run: |
        # Bootstrap CDK if needed (idempotent)
        export CDK_DEFAULT_ACCOUNT=${{ secrets.AWS_ACCOUNT_ID }}
        export CDK_DEFAULT_REGION=${{ env.AWS_REGION }}
        npx cdk bootstrap aws://${{ secrets.AWS_ACCOUNT_ID }}/${{ env.AWS_REGION }}
        
        # Deploy the stack with retry logic
        STACK_NAME="${{ steps.environment.outputs.stack_name }}"
        MAX_RETRIES=3
        RETRY_COUNT=0
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          echo "ðŸš€ Deployment attempt $((RETRY_COUNT + 1))/$MAX_RETRIES"
          
          if npx cdk deploy $STACK_NAME \
            --require-approval never \
            --outputs-file cdk-outputs.json; then
            echo "âœ… Deployment successful!"
            break
          else
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "âŒ Deployment failed. Waiting 30 seconds before retry..."
              sleep 30
            else
              echo "âŒ All deployment attempts failed."
              exit 1
            fi
          fi
        done

    - name: ðŸ”„ Update ECS service with new image
      run: |
        # Get stack outputs
        CLUSTER_NAME=$(aws cloudformation describe-stacks \
          --stack-name ${{ steps.environment.outputs.stack_name }} \
          --query 'Stacks[0].Outputs[?OutputKey==`ClusterName`].OutputValue' \
          --output text)
        
        SERVICE_NAME=$(aws cloudformation describe-stacks \
          --stack-name ${{ steps.environment.outputs.stack_name }} \
          --query 'Stacks[0].Outputs[?OutputKey==`ServiceName`].OutputValue' \
          --output text)

        echo "ðŸ“Š Cluster: $CLUSTER_NAME"
        echo "ðŸ“Š Service: $SERVICE_NAME"
        
        # Force new deployment with updated image
        aws ecs update-service \
          --cluster $CLUSTER_NAME \
          --service $SERVICE_NAME \
          --force-new-deployment \
          --no-cli-pager

        echo "â³ Waiting for service to stabilize..."
        aws ecs wait services-stable \
          --cluster $CLUSTER_NAME \
          --services $SERVICE_NAME

    - name: ðŸ” Health check deployment
      run: |
        # Get load balancer DNS from stack outputs
        ALB_DNS=$(aws cloudformation describe-stacks \
          --stack-name ${{ steps.environment.outputs.stack_name }} \
          --query 'Stacks[0].Outputs[?OutputKey==`LoadBalancerDNS`].OutputValue' \
          --output text)
        
        API_URL="http://$ALB_DNS"
        echo "ðŸŒ API URL: $API_URL"
        
        # Wait for ALB to be ready and perform health check
        for i in {1..30}; do
          if curl -f -s "$API_URL/health" > /dev/null 2>&1; then
            echo "âœ… API health check passed"
            HEALTH_RESPONSE=$(curl -s "$API_URL/health")
            echo "ðŸ“Š Health response: $HEALTH_RESPONSE"
            break
          fi
          echo "â³ Waiting for API to be ready... (attempt $i/30)"
          sleep 10
        done

    - name: ðŸŽ‰ Deployment Summary
      run: |
        ALB_DNS=$(aws cloudformation describe-stacks \
          --stack-name ${{ steps.environment.outputs.stack_name }} \
          --query 'Stacks[0].Outputs[?OutputKey==`LoadBalancerDNS`].OutputValue' \
          --output text)
        
        API_URL="http://$ALB_DNS"
        
        echo "## ðŸš€ ECS Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Environment:** ${{ steps.environment.outputs.env }}" >> $GITHUB_STEP_SUMMARY
        echo "**Stack:** ${{ steps.environment.outputs.stack_name }}" >> $GITHUB_STEP_SUMMARY
        echo "**Image Tag:** ${{ steps.environment.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸŒ Application URLs" >> $GITHUB_STEP_SUMMARY
        echo "- **API:** $API_URL" >> $GITHUB_STEP_SUMMARY
        echo "- **API Docs:** $API_URL/docs" >> $GITHUB_STEP_SUMMARY
        echo "- **Health Check:** $API_URL/health" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“¦ Container Image" >> $GITHUB_STEP_SUMMARY
        echo "- **Image:** \`${{ env.REGISTRY }}/${{ env.API_IMAGE_NAME }}:${{ steps.environment.outputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ—ï¸ Infrastructure" >> $GITHUB_STEP_SUMMARY
        echo "- **Deployment Type:** AWS ECS Fargate" >> $GITHUB_STEP_SUMMARY
        echo "- **Load Balancer:** Application Load Balancer" >> $GITHUB_STEP_SUMMARY
        echo "- **Auto Scaling:** Enabled (CPU/Memory based)" >> $GITHUB_STEP_SUMMARY  
        echo "- **Health Checks:** Automated with auto-recovery" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸš€ Optimization" >> $GITHUB_STEP_SUMMARY
        if [ "${{ needs.detect-changes.outputs.api-changed }}" = "true" ]; then
          echo "- **Build:** âœ… Executed (API changes detected)" >> $GITHUB_STEP_SUMMARY
        else
          echo "- **Build:** â© Skipped (no API changes)" >> $GITHUB_STEP_SUMMARY
        fi